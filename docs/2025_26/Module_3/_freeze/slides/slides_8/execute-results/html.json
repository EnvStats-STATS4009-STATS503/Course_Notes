{
  "hash": "97b7a708e1c6ee9f89ff79ce1a3a5e41",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Modelling Geostatistical Data\"\nformat:\n  revealjs:\n    embed-resources: true\n    footer: '<a href=\"https://envstats-stats4009-stats503.github.io/Course_Notes/2025_26/Module_3/docs/\" style=\"color:#ccc; padding:20px 30px; display:inline-block; margin:-20px -30px;\">Home</a>'\n    margin: 0\n    logo:  UofG.png\n    theme: uofg_theme.scss\n    header-includes: |\n      <script src=\"custom.js\" type=\"application/javascript\"></script>\ntitle-slide-attributes: \n  data-background-image: uog_cloistures2.jpg\n  data-background-color: \"#FFFFFF\"\nslide-number: true\nauthor:\n  - name: Jafet Belmont \n    email: jafet.BelmontOsuna@glasgow.ac.uk \n    affiliations: School of Mathematics and Statistics\neditor_options: \n  chunk_output_type: console\nexecute: \n  freeze: auto\nchalkboard: false\n---\n\n\n\n\n\n\n# Geostatistical modelling\n\n## Geostatistical Data {.smaller}\n\nIn many ecological and environmental settings, measurements are taken from fixed sampling units, aiming to quantify spatial variation and interpolate values at unobserved sites.\n\n:::::: columns\n:::: {.column width=\"60%\"}\n::: incremental\n-   Geostatistical data are the most common form of spatial data found in environmental and ecological settings.\n-   We regularly take measurements of an environmental variable of interest at a set of fixed locations.\n-   This could be data from samples taken across a region (eg., water depth in a lake) or from monitoring stations as part of a network (e.g., air pollution).\n-   In each of these cases, our goal is to estimate the value of our variable across the entire space.\n:::\n::::\n\n::: {.column width=\"40%\"}\n![](figures/monitoring_net.jpg){fig-align=\"center\" width=\"475\"}\n:::\n::::::\n\n## Understanding our region\n\n::: incremental\n-   Let $D$ be our two-dimensional region of interest.\n-   In principle, there are infinitely many locations within $D$, each of which can be represented by mathematical coordinates (e.g. latitude and longitude).\n-   We can identify any individual location as $\\mathbf{s}_i = (x_i, y_i)$, where $x_i$ and $y_i$ are their coordinates.\n-   We can treat our variable of interest as a random variable, $Z$ which can be observed at any location as $Z(\\mathbf{s}_i)$.\n:::\n\n## Geostatistical process\n\n-   A geostatistical process can therefore be written as: $$\\{Z(\\mathbf{s}); \\mathbf{s} \\in D\\}$$\n-   In practice, data are observed at a finite number of locations, $m$, and can be denoted as: $$z = \\{z(\\mathbf{s}_1), \\ldots z(\\mathbf{s}_m) \\}$$\n-   We have observed our data at $m$ locations, but often want to predict this process at a set of unknown locations.\n-   For example, what is the value of $z(\\mathbf{s}_0)$, where $\\mathbf{s}_0$ is an unobserved site?\n\n# Spatial Dependence\n\n## Spatial autocorrelation\n\n-   The key challenge in modelling geostatistical data is understanding **correlation**.\n-   Typically observations close together in space will be more similar than those which are further apart.\n-   Spatial correlation is usually driven by some unmeasured confounding variable(s) - for example, air pollution is spatially correlated because nearby areas tend to experience similar traffic levels.\n-   It is important that we account for these correlations in our analysis - failing to do so will lead to poor inference.\n\n## Modelling geostatistical data\n\nFor a set of geostatistical data $\\mathbf{z} = \\{ z(\\mathbf{s}_1), \\ldots, z(\\mathbf{s}_m) \\}$, we can consider the general model:\n\n$$Z(\\mathbf{s}_i) = \\mu(\\mathbf{s}_i) + e(\\mathbf{s}_i)$$\n\n::: incremental\n-   $\\mu(\\mathbf{s}_i)$ is a mean function which models trend and covariate effects.\n\n-   Then $e(\\mathbf{s}_i)$ is the error process which accounts for any spatial correlation which exists after accounting for $\\mu(\\mathbf{s}_i)$\n\n-   Spatial statistics is therefore often focused on understanding the process for $e(\\mathbf{s}_i)$.\n:::\n\n## Our key problem(s)\n\n::: incremental\n-   We have observations at $m$ locations $$\\mathbf{z} = \\{ z(\\mathbf{s}_1), \\ldots, z(\\mathbf{s}_m) \\}.$$\n-   We want to use these to obtain an estimate of $Z(\\mathbf{s}_0)$ where $\\mathbf{s}_0$ is an unobserved location.\n-   How do we model the spatial dependence between our observed sites $\\mathbf{s}_1, \\ldots, \\mathbf{s}_m$?\n-   What does this tell us about the dependence between our observed sites and our unobserved site $\\mathbf{s}_0$?\n:::\n\n## Variograms\n\nThe first step is to assess whether there is any evidence of spatial dependency in our data.\n\n-   Spatial dependence in georeferenced data can be explored by a function known as a variogram $2\\gamma(\\cdot)$ (or semivariogram $\\gamma(\\cdot)$).\n\n-   The variogram is similar in many ways to the autocorrelation function used in time series modelling.\n\n-   In simple terms, it is a function which measures the difference in the spatial process between a pair of locations a fixed distance apart.\n\n## Variograms\n\nThe variogram measures the variance of the difference in the process $Z(\\cdot)$ at two spatial locations $\\mathbf{s}$ and $\\mathbf{s+h}$ and is defined as :\n\n$$\\mathrm{Var}[Z(\\mathbf{s}) - Z(\\mathbf{s} + \\mathbf{h})] = E[(Z(\\mathbf{s}) - Z(\\mathbf{s} + \\mathbf{h}))^2] = 2\\gamma_z(\\mathbf{h}).$$\n\nNote that in practice we use the semi-variogram $\\gamma_z(\\mathbf{h})$ because our points come in pairs, and the semi-variance is equivalent to the variance per point at a given lag.\n\n::: incremental\n-   When the variance of the difference $Z(\\mathbf{s}) - Z(\\mathbf{s} + \\mathbf{h})$ is relatively small, then $Z(\\mathbf{s})$ and $Z(\\mathbf{s} + \\mathbf{h})$ are similar (spatially correlated).\n\n-   When the variance of the difference $Z(\\mathbf{s}) - Z(\\mathbf{s} + \\mathbf{h})$ is relatively large, then $Z(\\mathbf{s})$ and $Z(\\mathbf{s} + \\mathbf{h})$ are less similar (closer to independence).\n:::\n\n## Variograms {background-color=\"#FFFFFF\"}\n\n:::::: {style=\"font-size: 0.8em;\"}\nA plot of the empirical semivariogram against the separation distance conveys important information about the continuity and spatial variability of the process.\n\n:::: {.column width=\"40%\"}\n::: {style=\"font-size: 0.8em;\"}\n-   The **sill** is the maximum variance as $h \\to \\infty$.\n-   The **partial sill** represents the spatially structured variability\n-   The **nugget** is the minimum variance as $h \\to 0$ and represents the variability at distances smaller than sampling interval.\n-   The **range** is the distance to the sill.\n-   Points further apart than the range are assumed to be uncorrelated.\n:::\n::::\n\n::: {.column width=\"60%\"}\n![](figures/Variogram.png){fig-align=\"center\" width=\"389\"}\n:::\n::::::\n\n## Example: Construction a Variogram {auto-animate=\"true\" background-color=\"#FFFFFF\"}\n\nIn practice, we only have access to $m$ realisations of this process, and therefore we have to estimate the variogram. This is known as the **empirical variogram**.\n\nThe empirical semivariogram can be used as exploratory tool to assess whether data present spatial correlation.\n\nWe obtain this by computing the semi-variance for all possible pairs of observations: $\\gamma(\\mathbf{s}, \\mathbf{s} + \\mathbf{h}) = 0.5(Z(\\mathbf{s}) - Z(\\mathbf{s} + \\mathbf{h}))^2$.\n\n## Example: Constructing a Variogram {.smaller auto-animate=\"true\" background-color=\"#FFFFFF\"}\n\nThe data Paraná from the `geoR` Package contains the average rainfall over different years for the period May to June at 123 monitoring stations in Paraná state, Brazil.\n\n![Rainfall values measured at 143 recording stations in Paraná state, Brazil with low values being represented in blue and high values in red.](figures/parana.png){fig-align=\"center\" width=\"586\"}\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n\n\n## Example: Construction a Variogram {.smaller auto-animate=\"true\" background-color=\"#FFFFFF\"}\n\nTo illustrate how an empirical variogram is computed, consider the two highlighted locations below.\n\n![](figures/parana_ex1.png){fig-align=\"center\" width=\"586\"}\n\n## Example: Construction a Variogram {.smaller auto-animate=\"true\" background-color=\"#FFFFFF\"}\n\nTo illustrate how an empirical variogram is computed, consider the two highlighted locations below.\n\n:::::: columns\n::: {.column width=\"50%\"}\n![](figures/parana_ex1.png){fig-align=\"center\" width=\"586\"}\n:::\n\n:::: {.column width=\"50%\"}\n::: incremental\n1.  We can first compute the distance between the two locations using the Euclidean distance formula $$h = \\sqrt{(475.1 - 403)^2 + (83.6 - 164.5)^2} = 108.36$$\n\n2.  Next, we compute the semi-variance between the points using their observed values as $$\\begin{aligned}\\gamma(\\mathbf{s}, \\mathbf{s}+\\mathbf{h}) &= 0.5(Z(\\mathbf{s}) - Z(\\mathbf{s}+\\mathbf{h}))^2 \\\\ &= 0.5(315.33 - 306.9)^2 = 35.53\\end{aligned}$$\n\n3.  We repeat this process for every possible pair of points, and plot $h$ against $\\gamma(\\mathbf{s}, \\mathbf{t})$ for each.\n:::\n::::\n::::::\n\n## Example: Construction a Variogram {.smaller auto-animate=\"true\" background-color=\"#FFFFFF\"}\n\nWe can calculate the empirical variogram for the data using the `variogram` function from the `gstat` library.\n\n::::: columns\n::: {.column width=\"60%\"}\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Empirical variogram values corresponding to the rainfall data in Paraná state, Brazil.](slides_8_files/figure-revealjs/unnamed-chunk-2-1.png){fig-align='center' width=60%}\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"40%\"}\n-   This plot shows the semi-variances for each pair of points.\n\n-   Each pair of points has a different distance, making it difficult to use this for prediction.\n:::\n:::::\n\n## Binned variogram\n\nTo make the variogram easier to use and interpret, we divide the distances into a set of discrete bins, and compute the average semi-variance in each.\n\n-   We compute this binned empirical variogram as $$\\gamma(\\mathbf{h}) = \\frac{1}{2N(h_k)}\\sum_{(\\mathbf{s},\\mathbf{t}) \\in N(h_k)}[z(\\mathbf{s}) - z(\\mathbf{s}+\\mathbf{h})]^2$$\n-   Here, $k$ is the number of bins and $N(h_k)$ is the number of points in the bin with average distance $h$.\n-   We then construct a plot of our empirical variogram and use this to estimate the covariance structure.\n\n## Binned variogram {.smaller background-color=\"#FFFFFF\"}\n\nThe bins are illustrated on the left, and the empirical variogram obtained from them is shown on the right.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](slides_8_files/figure-revealjs/unnamed-chunk-3-1.png){fig-align='center' width=60%}\n:::\n:::\n\n\n\n\n## Do we observe any spatial dependence? {.smaller background-color=\"#FFFFFF\"}\n\nWe can construct null envelope based on permutations of the data values across the locations, i.e. envelopes built under the assumption of no spatial correlation.\n\n:::::: columns\n:::: {.column width=\"50%\"}\n::: incremental\n-   By overlapping these envelopes with the empirical variograms we can determine whether there is some spatial dependence in our data\n\n-   We can construct permutation envelopes on the empirical variogram using the `envelope` function from the `variosig` R package.\n\n-   In this example, we observe that the variogram only falls outside of the null envelope at distances $<200$m and also at distances above $300$m.\n\n-   Once we have computed an empirical variogram, we have to think about model fitting.\n:::\n::::\n\n::: {.column width=\"50%\"}\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](slides_8_files/figure-revealjs/unnamed-chunk-4-1.png){fig-align='center' width=60%}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"There are 13 out of 15 variogram estimates outside the 95% envelope.\"\n```\n\n\n:::\n:::\n\n\n\n:::\n::::::\n\n# Spatial Modelling\n\n## What We Observed and What We Did Not {.smaller}\n\nWe treat the observed process of interest as being measured with error\n\n$$\n(\\text{observed value})_i = (\\text{true value at location } i) + (\\text{error})_i\n$$\n\nalternatively\n\n$$\ny_i = Z(\\mathbf{s}_i) + \\varepsilon_i\n$$\n\nWhen geostatistical data are considered, we can often assume that there is a spatially continuous variable underlying the observations that can be modeled using a **random field**.\n\n::: incremental\n-   we have a process that is occurring everywhere in space $\\rightarrow$ natural to try to model it using some sort of function (of space)\n\n-   a **random field** is a random function that generates smooth surfaces\n\n-   This is hard\n\n-   We typically make our lives easier by making everything Gaussian\n:::\n\n## Gaussian Random Fields {.smaller auto-animate=\"true\"}\n\nA **Gaussian random field** (GRF) is a collection of random variables, where observations occur in a continuous domain, and where every finite collection of random variables has a multivariate normal distribution\n\n$$\n\\mathbf{z} = (z(\\mathbf{s}_1),\\ldots,z(\\mathbf{s}_m)) \\sim N(\\mu(\\mathbf{s}_1),\\ldots,\\mu(\\mathbf{s}_m),\\Sigma),\n$$\n\nwhere $\\Sigma_{ij} = \\mathrm{Cov}(z(\\mathbf{s}_i),z(\\mathbf{s}_j))$ is a dense $m \\times m$ matrix.\n\n::: incremental\n-   This is actually quite tricky: $\\Sigma$ will need to depend on the set of observation sites and has to behave well (be \"*positive definite*\")\n-   Use a covariance function $C_z(\\cdot,\\cdot)$ that depends on the distance ($\\Sigma_{ij} = C_z(\\mathbf{s}_i,\\mathbf{s}_j)$) between two points and that\n    -   has no negative variances\n    -   is symmetric\n    -   is decreasing, with maximum at distance = 0\n-   $C_z(\\mathbf{s}_i, \\mathbf{s}_j)$ measures the strength of the linear dependence between $Z(\\mathbf{s}_i)$ and $Z(\\mathbf{s}_j)$.\n-   $C_z(\\mathbf{s}_i, \\mathbf{s}_j) = \\mathrm{Var}(Z(\\mathbf{s}_i))$ for $i = j$.\n:::\n\n## Stationary and isotropy {.smaller}\n\nWe will assume our *Gaussian process* can be described as weakly stationary if the following criteria are met:\n\n$E[{Z(\\mathbf{s})}] = \\mu_z(\\mathbf{s}) = \\mu_z$ - a finite constant which does not depend on $\\mathbf{s}$.\n\n$\\text{Cov}(Z(\\mathbf{s}_i),Z(\\mathbf{s}_j)) = C_z(\\mathbf{s}_i-\\mathbf{s}_j)$ - a finite constant which can depend on distance $(\\mathbf{s}_i-\\mathbf{s}_j)$.\n\n-   Condition 1 states that our mean function must be constant in space, with no overall spatial trend.\n\n-   Condition 2 states that for any two locations, their covariance depends only on how far apart they are (their spatial lag, $h$), not their absolute position.\n\nOur process is said to be isotropic if the covariance function is directionally invariant. This means that the covariance only depends on the euclidean distance $(||\\mathbf{s}_i-\\mathbf{s}_j||)$ and not the direction.\n\n## Building the model {.smaller}\n\nThe first step in defining a model for a random field in a hierarchical framework is to identify a probability distribution for the observations available at $m$ sampled spatial locations and represented by the vector $\\mathbf{y} = y_1,\\ldots,y_m$.\n\nFor example, if we assume our observations follow a Gaussian distribution then\n\n$$\n\\begin{aligned}\nY_i &\\sim N(\\mu_i,\\tau_e^{-1})\\\\\n\\eta_i &=\\mu_i = \\beta_0 + \\ldots + Z(\\mathbf{s}_i)\n\\end{aligned}\n$$\n\n-   $\\tau_e^{-1} = \\sigma^2_e$ represents the variance of the zero-mean measurement error (equivalent to the nugget effect)\n\n-   The response mean $\\mu_i$ which coincides with the linear predictor $\\eta_i$ is defined based on:\n\n    -   the intercept $\\beta_0$ and any additional covariates\n\n    -   the realization of the latent (*unobservable*) GF $Z(\\mathbf{s}) \\sim \\mathrm{MVN}(0,\\Sigma)$ which accounts for the spatial correlation through $\\Sigma = C_z(\\cdot,\\cdot)$.\n\n## The Matérn Field {.smaller}\n\nA commonly used covariance function is the Matérn covariance function. The covariance of two points which are a distance $h$ apart is:\n\n$$\n    \\Sigma =C_{\\nu}(h) = \\sigma^2 \\frac{2^{1-\\nu}}{\\Gamma(\\nu)} \\left( \\frac{\\sqrt{2\\nu} h}{\\rho} \\right)^{\\nu} K_{\\nu} \\left( \\frac{\\sqrt{2\\nu} h}{\\rho} \\right)\n$$\n\n-   $\\Gamma(\\cdot)$ is the gamma function\n\n-   $K_{\\nu}(\\cdot)$ is the modified Bessel function of the second kind.\n\n-   Parameters $\\sigma^2$, $\\rho$ and $\\nu$ are non-negative values of the covariance function.\n\n    -   $\\sigma^2$ is the *spatially structured* variance component\n\n    -   $\\rho$ is the range of the spatial process\n\n    -   $\\nu$ controls smoothness of the spatial process.\n\n## Big *n* problem!\n\nThe disadvantage of the modelling approach involving the spatial covariance function is known as \"big *n* problem\" and concerns the computational costs required for algebra operations with dense covariance matrices (such as $\\Sigma$).\n\nIn particular dense matrix operations scale cubically with the matrix size, given by the number of locations where the process is observed. A computationally effective alternative is given by the stochastic partial differential equation (SPDE) approach\n\n## The SPDE approach\n\nWe define a (Matérn) GRF as the solution of a stochastic partial differential equation (SPDE)\n\n$$\n(\\kappa^2-\\Delta)^{\\alpha/2}Z(t) = W(t)\n$$\n\nWhat is this?\n\n-   $W(t)$ is random noise\n-   $\\omega(t)$ is the smooth process we want\n-   $(\\kappa^2-\\Delta)^{\\alpha/2}$ is an operator that \"smooths\" the white noise.\n-   $\\kappa$ and $\\alpha$ are parameters\n\n## **One analogy** {.smaller auto-animate=\"true\" background-color=\"#FFFFFF\"}\n\n:::::: columns\n:::: {.column width=\"40%\"}\nImagine a guitar string stretched from left to right.\n\n-   Now imagine someone randomly taps along it at many locations:\n\n    ::: incremental\n    -   Each tap is independent\n    -   Some taps are strong, some weak\n    -   There is no coordination between taps\n    -   A tap at one location tells you nothing about a tap nearby\n    :::\n\n::: fragment\n*This is pure randomness.* But a real string does not behave like this\n:::\n::::\n\n::: {.column width=\"60%\"}\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](slides_8_files/figure-revealjs/unnamed-chunk-5-1.png){fig-align='center' width=60%}\n:::\n:::\n\n\n\n:::\n::::::\n\n::: notes\nNo smoothness\n\nSharp up/down jumps\n\nNo gentle waves\n\nNo continuity in behavior\n\nThat's because nothing connects one tap to the next.\n:::\n\n## **One analogy** {.smaller auto-animate=\"true\" background-color=\"#FFFFFF\"}\n\n:::::: columns\n:::: {.column width=\"40%\"}\nImagine a guitar string stretched from left to right.\n\n-   The rope has tension and stiffness\n    -   the tension spreads each tap to nearby points\n    -   Sharp jumps are softened. $(\\kappa^2-\\Delta)^{\\color{red}{\\alpha}/2}Z(t) = W(t)$\n\n::: fragment\n-   $\\Delta$ measures the local curvature\n-   $\\kappa$ controls how far randomness propagates\n-   stronger tension (large $\\kappa$) = stronger pull\n\n$$(\\color{red}{\\kappa^2}-\\Delta)Z(t) = W(t), ~~~\\text{for } \\alpha=2$$\n:::\n::::\n\n::: {.column width=\"60%\"}\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](slides_8_files/figure-revealjs/unnamed-chunk-6-1.png){fig-align='center' width=60%}\n:::\n:::\n\n\n\n:::\n::::::\n\n::: notes\nMeasure the bending at $z_i$ by taking the with respect the average of the neighbours (i.e. $z_i - (z_{i-1}+z_i/2) = z_{i-1} + 2z_i +z_{i+1}$).\n\n-   if $= 0 \\rightarrow$ straight\n\n-   if the diff is large $\\rightarrow$ sharply bent\n\n-   the sign tells you which way it bends\n\nThe curvature need to divide by the spacing $h$ between points (assuming equal spacing), i.e., $(z_{i-1} + 2z_i +z_{i+1}) \\times h^{-2}$.\n\nIn a continuous space we measured this by taking the second derivative, i.e. the Laplacian operator\n\nAs $h\\to 0$ we measure the rate of change of slope, i.e. curvature as:\n\n$$(z_{i-1} + 2z_i +z_{i+1}) \\times h^{-2}  \\to \\frac{\\partial z}{\\partial t^2} = \\Delta z$$ Where $z(x)$ is the displacement of the string at position $t$.\n\nTension ($\\kappa$): resists large displacement If a tap pushes part of the string far up or down:\n\n-   tension pulls it back\n-   stronger tension = stronger pull\n\n$$\n\\begin{aligned}\n(\\color{red}{\\kappa^2}-\\Delta)Z(t) &= W(t) \\\\\n\\color{red}{\\kappa^2}Z(t) - \\Delta Z(t) &= W(t)\\\\\n\\text{if } Z(t) \\text{ is large then }& \\color{tomato}{\\kappa^2 Z(t)} \\text{ becomes large too} \\\\\n\\text{large pull}-\\text{back bending}&=\\text{random tap}\n\\end{aligned}\n$$ In this case, To balance the equation, $Z(t)$ must be smaller.\n:::\n\n## **One analogy** {.smaller auto-animate=\"true\" background-color=\"#FFFFFF\"}\n\n:::::: columns\n:::: {.column width=\"40%\"}\nImagine a guitar string stretched from left to right.\n\n-   The rope has tension and stiffness\n    -   the tension spreads each tap to nearby points\n    -   Sharp jumps are softened.\n\n::: fragment\n-   Stiffness = controls how smooth the field becomes ($\\alpha$)\n-   Larger $\\alpha$ smoother the process will be\n\n$$\n(\\kappa^2-\\Delta)^{\\color{red}{\\alpha}/2}Z(t) = W(t)\n$$\n:::\n::::\n\n::: {.column width=\"60%\"}\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](slides_8_files/figure-revealjs/unnamed-chunk-7-1.png){fig-align='center' width=60%}\n:::\n:::\n\n\n\n:::\n::::::\n\n::: notes\nLastly $\\alpha$ controls how *smooth* the final shape. E.g.,\n\n$$\nW(t) = \\begin{cases}\n(\\kappa^2-\\Delta)Z(t) & \\text{if } \\alpha= 2 \\text{ i.e., string resists curvature once}\\\\\n(\\kappa^2-\\Delta)^2Z(t) & \\text{if } \\alpha= 4 \\text{ i.e., string resists curvature twice}\n\\end{cases}\n$$\n\nTake the white noise $W(t)$ and smooth it once by the operator $(\\kappa^2 - \\Delta)^{-1}$ so the operator filters the white noise once\n\n-   it reduces sharp spikes\n\n-   but still leaves some visible bumps\n\nAt $\\alpha=2$ we smooth the result again.. Each pass removes high-frequency components (sharp bumps)\n:::\n\n## Solving the SPDE {.smaller background-color=\"#FFFFFF\" auto-animate=\"true\"}\n\nOk...but we still need to solve the SPDE to find $Z(t)$!\n\n. . .\n\nNow we need to discretize the domain into T points (we cannot compute on the continuous!)\n\n. . .\n\n::::: columns\n::: {.column width=\"50%\"}\nWe represent our solution as\n\n$$\nZ(t) = \\sum_{i = 1}^T\\psi_i(t)w_i\n$$\n\nWhere\n\n-   $\\psi_i(t)$ are (known) basis functions for nodes $i=1,\\ldots,T$\n\n    -   $\\psi_i(t_i)= 1$\n\n    <!-- -->\n\n    -   $\\psi_i(t_j) = 0 ~~\\forall~~i \\neq j$\n\n    <!-- -->\n\n    -   Linear between neighboring nodes\n:::\n\n::: {.column width=\"50%\"}\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](slides_8_files/figure-revealjs/unnamed-chunk-8-1.png){fig-align='center' width=70%}\n:::\n\n::: {.cell-output-display}\n![](slides_8_files/figure-revealjs/unnamed-chunk-8-2.png){fig-align='center' width=70%}\n:::\n:::\n\n\n\n:::\n:::::\n\n::: notes\n-   \"solving the SPDE\" means Find a random function $Z(t)$ such that the equality $(\\kappa^2-\\Delta)^{\\alpha/2}Z(t) = W(t)$ holds in distribution.\n-   in other words find $Z(s)$ such that when the operator $(\\kappa^2-\\Delta)^{\\alpha/2}$ is applied to it, it produces white noise\n-   OR, The Matérn field is the Gaussian field $Z(s)$ produced by smoothing white noise $W(t)$ through the inverse operator $(\\kappa^2-\\Delta)^{\\alpha/2}$.\n-   The Matérn field is infinite-dimensional so we approximate it using a finite basis expansion\n    -   we want a simple local basis\n    -   each basis only affects neighbors\n    -   so computations become sparse\n-   Each weight $w_i$ is basically the value of the field at node $i$\n-   The basis functions are:\n    -   Height = 1 at node\n    -   Zero at neighboring nodes\n    -   Linear in between\n-   A hat function is not the field. It is a *building block* for the field.\n-   the field between nodes is interpolated linearly so the vector of weights fully defines the approximate field.\n-   Since the SPDE is linear and the white noise is Gaussian, the solution is Gaussian\n:::\n\n## Solving the SPDE {.smaller background-color=\"#FFFFFF\" auto-animate=\"true\"}\n\nOk...but we still need to solve the SPDE to find $Z(t)$!\n\nNow we need to discretize the domain into T points (we cannot compute on the continuous!)\n\n::::: columns\n::: {.column width=\"50%\"}\nWe represent our solution as\n\n$$\nZ(t) = \\sum_{i = 1}^T\\psi_i(t)w_i\n$$\n\nWhere\n\n-   $\\psi_i(t)$ are (known) basis functions for nodes $i=1,\\ldots,T$\n\n-   $w_i$ are (unknown) weights\n\n    -   the field value $Z(s)$ is a **linear interpolation** between the two neighboring weights\n:::\n\n::: {.column width=\"50%\"}\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](slides_8_files/figure-revealjs/unnamed-chunk-9-1.png){fig-align='center' width=70%}\n:::\n\n::: {.cell-output-display}\n![](slides_8_files/figure-revealjs/unnamed-chunk-9-2.png){fig-align='center' width=70%}\n:::\n:::\n\n\n\n:::\n:::::\n\n::: notes\n-   \"solving the SPDE\" means Find a random function $Z(t)$ such that the equality $(\\kappa^2-\\Delta)^{\\alpha/2}Z(t) = W(t)$ holds in distribution.\n-   in other words find $Z(s)$ such that when the operator $(\\kappa^2-\\Delta)^{\\alpha/2}$ is applied to it, it produces white noise\n-   OR, The Matérn field is the Gaussian field $Z(s)$ produced by smoothing white noise $W(t)$ through the inverse operator $(\\kappa^2-\\Delta)^{\\alpha/2}$.\n-   The Matérn field is infinite-dimensional so we approximate it using a finite basis expansion\n    -   we want a simple local basis\n    -   each basis only affects neighbors\n    -   so computations become sparse\n-   Each weight $w_i$ is basically the value of the field at node $i$\n-   The basis functions are:\n    -   Height = 1 at node\n    -   Zero at neighboring nodes\n    -   Linear in between\n-   A hat function is not the field. It is a *building block* for the field.\n-   the field between nodes is interpolated linearly so the vector of weights fully defines the approximate field.\n-   Since the SPDE is linear and the white noise is Gaussian, the solution is Gaussian\n:::\n\n## Solving the SPDE {.smaller background-color=\"#FFFFFF\" auto-animate=\"true\"}\n\nOk...but we still need to solve the SPDE to find $Z(t)$!\n\nNow we need to discretize the domain into T points (we cannot compute on the continuous!)\n\n::::: columns\n::: {.column width=\"50%\"}\nWe represent our solution as\n\n$$\nZ(t) = \\sum_{i = 1}^T\\psi_i(t)w_i\n$$\n\nWhere\n\n-   $\\psi_i(t)$ are (known) basis functions for nodes $i=1,\\ldots,T$\n\n-   $w_i$ are (unknown) weights\n\n-   This solution is then approximated using a finite combination of piece-wise linear basis functions.\n\n-   The solution is completely defined by a Gaussian vector of weights with zero mean and a sparse precision matrix.\n:::\n\n::: {.column width=\"50%\"}\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](slides_8_files/figure-revealjs/unnamed-chunk-10-1.png){fig-align='center' width=70%}\n:::\n\n::: {.cell-output-display}\n![](slides_8_files/figure-revealjs/unnamed-chunk-10-2.png){fig-align='center' width=70%}\n:::\n:::\n\n\n\n:::\n:::::\n\n## The SPDE approach on 2D {.smaller auto-animate=\"true\"}\n\nNow we approximate the GRF using a triangulated mesh.\n\nThe SPDE approach represents the continuous spatial process as a continuously indexed Gaussian Markov Random Field (GMRF)\n\n-   We construct an appropriate lower-resolution approximation of the surface by sampling it in a set of well designed points and constructing a piece-wise linear interpolant.\n\n![](figures/spde.png){fig-align=\"center\" width=\"520\"}\n\n## The SPDE approach on 2D {.smaller auto-animate=\"true\"}\n\nNow we approximate the GRF using a triangulated mesh.\n\nThe SPDE approach represents the continuous spatial process as a continuously indexed Gaussian Markov Random Field (GMRF)\n\n-   We construct an appropriate lower-resolution approximation of the surface by sampling it in a set of well designed points and constructing a piece-wise linear interpolant.\n\n-   Note that $\\nu = \\alpha - d/2$. For $\\alpha=2 \\Rightarrow \\nu= 1$ since $d=2$ we have that:\n\n::: {.callout-note icon=\"false\"}\n$$\n\\begin{aligned}\nZ(s) &= \\sum_{i = 1}^K\\psi_i(s)w_i \\\\\n\\mathbf{w} &\\sim N(\\mathbf{0},Q^{-1}) \\leftarrow \\text{GMRF}\\\\\nQ^{-1} &= \\tau^2(\\kappa^4 \\mathbf{C} + 2\\kappa^2 \\mathbf{G}+\\mathbf{G}\\mathbf{C}^{-1}\\mathbf{G})\n\\end{aligned}\n$$\n\n-   $\\mathbf{C}$ is diagonal with entries $C_{ii} =\\int \\psi_i(s)\\mathrm{d}s$ and measures how much of the domain each basis function covers.\n\n-   $G_{ij} = \\int \\nabla \\psi_i(s) \\nabla \\psi_j(s) \\mathrm{d}s$ reflects the connectivity of the mesh nodes.\n\n-   because each basis function overlaps only with nearby ones, the resulting precision matrix is sparse, meaning each coefficient depends directly only on its neighbors\n:::\n\n::: notes\nwe approximate a continuous string/field using local \"hat2 shapes;\n\n-   C just measures how much space each hat covers (mass/area),\n-   G measures how strongly neighboring hats resist bending\n:::\n\n## In summary {.smaller}\n\n-   The continuous Matérn GRF is the solution of a SPDE and is represented as\n\n$$\nZ(s) = \\sum_{i = 1}^K\\psi_i(s)w_i\n$$\n\n-   The weights vector $\\mathbf{w} = (w_1,\\dots,w_K)$ is Gaussian with a **sparse** precision matrix $\\longrightarrow$ Computational convenience\n\n-   The field has two parameters\n\n    -   The range $\\rho$\n    -   The marginal variance $\\sigma^2$\n\n-   These parameters are linked to the parameters of the SPDE\n\n-   We need to assign prior to them\n\n## Penalized Complexity (PC) priors\n\nPenalized Complexity (PC) priors proposed by Simpson et al. ([2017](https://projecteuclid.org/journals/statistical-science/volume-32/issue-1/Penalising-Model-Component-Complexity--A-Principled-Practical-Approach-to/10.1214/16-STS576.full)) allow us to control the amount of spatial smoothing and avoid overfitting.\n\n-   PC priors shrink the model towards a simpler baseline unless the data provide strong evidence for a more complex structure.\n-   To define the prior for the marginal precision $\\sigma^{-2}$ and the range parameter $\\rho$, we use the probability statements:\n    -   Define the prior for the range $\\text{Prob}(\\rho<\\rho_0) = p_{\\rho}$\n    -   Define the prior for the range $\\text{Prob}(\\sigma>\\sigma_0) = p_{\\sigma}$\n\n## Learning about the SPDE approach {.smaller}\n\n::: {style=\"height: 50px;\"}\n:::\n\n-   F. Lindgren, H. Rue, and J. Lindström. An explicit link between Gaussian fields and Gaussian Markov random fields: The SPDE approach (with discussion). In: *Journal of the Royal Statistical Society, Series B* 73.4 (2011), pp. 423–498.\n\n-   H. Bakka, H. Rue, G. A. Fuglstad, A. Riebler, D. Bolin, J. Illian, E. Krainski, D. Simpson, and F. Lindgren. Spatial modelling with R-INLA: A review. In: *WIREs Computational Statistics* 10:e1443.6 (2018). (Invited extended review). DOI: 10.1002/wics.1443.\n\n-   E. T. Krainski, V. Gómez-Rubio, H. Bakka, A. Lenzi, D. Castro-Camilio, D. Simpson, F. Lindgren, and H. Rue. *Advanced Spatial Modeling with Stochastic Partial Differential Equations using R and INLA*. Github version \\url{www.r-inla.org/spde-book}. CRC press, Dec. 20\n\n# Modelling Rainfall in Brazil {background-image=\"figures/parana_state.jpg\"}\n\n## Example: Modelling Rainfall in Brazil {background-color=\"#FFFFFF\"}\n\nLets revisit the Paraná data containing the average rainfall over different years for the period May to June at 123 monitoring stations in Paraná state, Brazil.\n\n![Rainfall values measured at 143 recording stations in Paraná state, Brazil with low values being represented in blue and high values in red.](figures/parana.png){fig-align=\"center\" width=\"586\"}\n\n## The Model {background-color=\"#FFFFFF\" auto-animate=\"true\"}\n\n-   **Stage 1** Model for the response $$\n    y(s)|\\eta(s)\\sim\\text{Normal}(\\mu(s),\\sigma^2_e)\n    $$\n\n-   **Stage 2** Latent field model $$\n    \\eta(s) = \\mu(s) = \\beta_0 + Z(s)\n    $$\n\n-   **Stage 3** Hyperparameters\n\n## The Model {background-color=\"#FFFFFF\" auto-animate=\"true\"}\n\n-   **Stage 1** Model for the response $$\n    y(s)|\\eta(s)\\sim\\text{Normal}(\\mu(s),\\sigma^2_e)\n    $$\n\n-   **Stage 2** Latent field model $$\n    \\eta(s) = \\mu(s) = \\beta_0 + Z(s)\n    $$\n\n    -   A global intercept $\\beta_0$\n    -   A Gaussian field $Z(s)$\n\n-   **Stage 3** Hyperparameters\n\n## The Model {background-color=\"#FFFFFF\" auto-animate=\"true\"}\n\n-   **Stage 1** Model for the response $$\n    y(s)|\\eta(s)\\sim\\text{Normal}(\\mu(s),\\sigma^2_e)\n    $$\n\n-   **Stage 2** Latent field model $$\n    \\eta(s) = \\mu(s) = \\beta_0 + Z(s)\n    $$\n\n-   **Stage 3** Hyperparameters\n\n    -   Precision for the observational error $\\tau_e = 1/\\sigma^{2}_e$\n    -   Range and sd in the Gaussian field $\\sigma_{\\omega}, \\tau_{\\omega}$\n\n## Step 1: Define the SPDE representation: The mesh {.smaller background-color=\"#FFFFFF\"}\n\n::::: columns\n::: {.column width=\"40%\"}\nFirst, we need to create the mesh used to approximate the random field.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(fmesher)\nlibrary(inlabru)\nlibrary(INLA)\n\nmesh <- fm_mesh_2d(\n  loc = parana_sf, \n  offset = c(50, 100),\n  cutoff = 1,\n  max.edge = c(30, 60)\n)\n```\n:::\n\n\n\n\n-   `max.edge` for maximum triangle edge lengths\n-   `offset` for inner and outer extensions (to prevent *edge effects*)\n-   `cutoff` to avoid overly small triangles in clustered areas\n:::\n\n::: {.column width=\"60%\"}\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](slides_8_files/figure-revealjs/unnamed-chunk-13-1.png){fig-align='center' width=60%}\n:::\n:::\n\n\n\n:::\n:::::\n\n## Step 1: Define the SPDE representation: The mesh\n\n::: incremental\n-   All random field models need to be discretised for practical calculations.\n\n-   The SPDE models were developed to provide a consistent model definition across a range of discretisations.\n\n-   We use finite element methods with local, piecewise linear basis functions defined on a triangulation of a region of space containing the domain of interest.\n\n-   Deviation from stationarity is generated near the boundary of the region.\n\n-   The choice of region and choice of triangulation affects the numerical accuracy.\n:::\n\n## Step 1: Define the SPDE representation: The mesh {background-color=\"#FFFFFF\"}\n\n-   If the mesh is too fine $\\rightarrow$ heavy computation\n\n-   If the mesh is to coarse $\\rightarrow$ not accurate enough\n\n![](figures/mesh_res.png){fig-align=\"center\"}\n\n## Step 1: Define the SPDE representation: The mesh\n\n**Some guidelines**\n\n-   Create triangulation meshes with `fm_mesh_2d()`:\n\n-   edge length should be around a third to a tenth of the spatial range\n\n-   Move undesired boundary effects away from the domain of interest by extending to a smooth external boundary:\n\n-   Use a coarser resolution in the extension to reduce computational cost (`max.edge=c(inner, outer)`), i.e., add extra, larger triangles around the border\n\n## Step 1: Define the SPDE representation: The mesh\n\n-   Use a fine resolution (subject to available computational resources) for the domain of interest (inner correlation range) and avoid small edges ,i.e., filter out small input point clusters (0 $<$ cutoff $<$ inner)\n\n-   Coastlines and similar can be added to the domain specification in `fm_mesh_2d()` through the `boundary` argument.\n\n-   simplify the border\n\n## Step 2: Define the SPDE representation: The SPDE {.smaller background-color=\"#FFFFFF\"}\n\nWe use the `inla.spde2.pcmatern` to define the SPDE model using PC priors through the following probability statements.\n\n-   The Paraná state is around 663.8711 kilometers width by 464.7481 kilometers height.\n-   The PC-prior for the practical range is built considering the probability of the practical range being less than a chosen distance.\n-   We chose to set the prior considering the median as 100 kilometers.\n\n::::: columns\n::: {.column width=\"40%\"}\n\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n\n:::\n\n::: {.column width=\"60%\"}\n-   $P(\\rho < 100) = 0.5$\n\n-   $P(\\sigma > 1) = 0.5$\n:::\n:::::\n\n![](figures/priors.png){fig-align=\"center\"}\n\n## Fit the Model {.smaller auto-animate=\"true\" background-color=\"#FFFFFF\"}\n\n::::: columns\n::: {.column width=\"50%\"}\n**The Model**\n\n$$\n\\begin{aligned}\ny(s)|\\eta(s)&\\sim\\text{Normal}(\\mu(s),\\sigma^2_e)\\\\\n\\eta(s) &  = \\color{red}{\\boxed{\\beta_0}} + \\color{red}{\\boxed{ Z(s)}}\\\\\n\\end{aligned}\n$$\n:::\n\n::: {.column width=\"50%\"}\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nparana_sf %>% print(n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 143 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 150.122 ymin: 70.36 xmax: 768.5087 ymax: 461.9681\nCRS:           NA\nFirst 3 features:\n   value                  geometry\n1 306.09 POINT (402.9529 164.5284)\n2 200.88  POINT (501.7049 428.771)\n3 167.07 POINT (556.3262 445.2706)\n```\n\n\n:::\n:::\n\n\n\n:::\n:::::\n\n**The code**\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-line-numbers=\"1-3\"}\n# define model component\ncmp = ~ -1 + Intercept(1) + space(geometry, model = spde_model)\n\n# define model predictor\neta = value ~ Intercept  + space\n\n# build the observation model\nlik = bru_obs(formula = eta,\n              data = parana_sf,\n              family = \"gaussian\")\n\n# fit the model\nfit = bru(cmp, lik)\n```\n:::\n\n\n\n\n## Fit the Model {.smaller auto-animate=\"true\" background-color=\"#FFFFFF\"}\n\n::::: columns\n::: {.column width=\"50%\"}\n**The Model**\n\n$$\n\\begin{aligned}\ny(s)|\\eta(s)&\\sim\\text{Normal}(\\mu(s),\\sigma^2_e)\\\\\n\\color{red}{\\boxed{\\eta(s)}} &  =\\color{red}{\\boxed{ \\beta_0 + Z(s)}}\\\\\n\\end{aligned}\n$$\n:::\n\n::: {.column width=\"50%\"}\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nparana_sf %>% print(n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 143 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 150.122 ymin: 70.36 xmax: 768.5087 ymax: 461.9681\nCRS:           NA\nFirst 3 features:\n   value                  geometry\n1 306.09 POINT (402.9529 164.5284)\n2 200.88  POINT (501.7049 428.771)\n3 167.07 POINT (556.3262 445.2706)\n```\n\n\n:::\n:::\n\n\n\n:::\n:::::\n\n**The code**\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-line-numbers=\"5-6\"}\n# define model component\ncmp = ~ -1 + Intercept(1) + space(geometry, model = spde_model)\n\n# define model predictor\neta = value ~ Intercept  + space\n\n# build the observation model\nlik = bru_obs(formula = eta,\n              data = parana_sf,\n              family = \"gaussian\")\n\n# fit the model\nfit = bru(cmp, lik)\n```\n:::\n\n\n\n\n## Fit the Model {.smaller auto-animate=\"true\" background-color=\"#FFFFFF\"}\n\n::::: columns\n::: {.column width=\"50%\"}\n**The Model**\n\n$$\n\\begin{aligned}\n\\color{red}{\\boxed{y(s)|\\eta(s)}} &\\sim\\text{Normal}(\\mu(s),\\sigma^2_e)\\\\\n\\eta(s) &  =\\beta_0 + Z(s)\\\\\n\\end{aligned}\n$$\n:::\n\n::: {.column width=\"50%\"}\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nparana_sf %>% print(n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 143 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 150.122 ymin: 70.36 xmax: 768.5087 ymax: 461.9681\nCRS:           NA\nFirst 3 features:\n   value                  geometry\n1 306.09 POINT (402.9529 164.5284)\n2 200.88  POINT (501.7049 428.771)\n3 167.07 POINT (556.3262 445.2706)\n```\n\n\n:::\n:::\n\n\n\n:::\n:::::\n\n**The code**\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-line-numbers=\"8-10\"}\n# define model component\ncmp = ~ -1 + Intercept(1) + space(geometry, model = spde_model)\n\n# define model predictor\neta = value ~ Intercept  + space\n\n# build the observation model\nlik = bru_obs(formula = eta,\n              data = parana_sf,\n              family = \"gaussian\")\n\n# fit the model\nfit = bru(cmp, lik)\n```\n:::\n\n\n\n\n## Fit the Model {.smaller auto-animate=\"true\" background-color=\"#FFFFFF\"}\n\n::::: columns\n::: {.column width=\"50%\"}\n**The Model**\n\n$$\n\\begin{aligned}\ny(s)|\\eta(s) &\\sim\\text{Normal}(\\mu(s),\\sigma^2_e)\\\\\n\\eta(s) &  =\\beta_0 + Z(s)\\\\\n\\end{aligned}\n$$\n:::\n\n::: {.column width=\"50%\"}\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nparana_sf %>% print(n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 143 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 150.122 ymin: 70.36 xmax: 768.5087 ymax: 461.9681\nCRS:           NA\nFirst 3 features:\n   value                  geometry\n1 306.09 POINT (402.9529 164.5284)\n2 200.88  POINT (501.7049 428.771)\n3 167.07 POINT (556.3262 445.2706)\n```\n\n\n:::\n:::\n\n\n\n:::\n:::::\n\n**The code**\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-line-numbers=\"12-13\"}\n# define model component\ncmp = ~ -1 + Intercept(1) + space(geometry, model = spde_model)\n\n# define model predictor\neta = value ~ Intercept  + space\n\n# build the observation model\nlik = bru_obs(formula = eta,\n              data = parana_sf,\n              family = \"gaussian\")\n\n# fit the model\nfit = bru(cmp, lik)\n```\n:::\n\n\n\n\n## Results {.smaller auto-animate=\"true\" background-color=\"#FFFFFF\"}\n\n::::: columns\n::: {.column width=\"40%\"}\n|                                         |    Mean |    2.5% |   97.5% |\n|:----------------------------------------|--------:|--------:|--------:|\n| Intercept                               | 249.714 | 232.748 | 264.983 |\n| Precision for the Gaussian observations |   4.482 |   3.197 |   5.511 |\n| Range for space                         |  57.328 |  46.234 |  70.330 |\n| Stdev for space                         |  46.654 |  41.222 |  52.736 |\n:::\n\n::: {.column width=\"60%\"}\n-   `Intercept` represents the average rainfall values\n-   `Precision for the Gaussian observations` are the observational errors\n-   `Range for space` is the correlation of the Matérn field\n-   `Stdev for space` is the marginal std deviation of the Matérn field\n:::\n:::::\n\n# Spatial predictions\n\n## How do we predict at unsampled locations? {.smaller}\n\nIn geostatistical applications, the main interest resides in the spatial prediction of the spatial latent field or of the response variable in new locations\n\n::: incremental\n-   Suppose we observe a spatial process ${Z(s): s \\in \\mathcal{D}}$ at locations $s_1,\\dots,s_n$.\n\n-   Our goal: **predict the variable of interest at an unobserved location** $s_0 \\in \\mathcal{D}$.\n\n    > given the data $y = (y_1,\\dots,y_n)$, what can we say about $Z(s_0)$?\n\n-   Rather than a single guess, we want a **full uncertainty-aware prediction**.\n\n-   In a Bayesian setting, prediction is a **probabilistic task**.\n:::\n\n## Posterior predictive density {.smaller}\n\nThe key lies in the **posterior predictive distribution**\n\n$$\n  \\pi(\\tilde{Y} \\mid y)\n  = \\int \\pi(\\tilde{Y} \\mid \\Theta, y)\\, \\pi(\\Theta \\mid y)\\, d\\Theta,\n$$ where $\\Theta$ denotes *all* latent components and hyperparameters.\n\n::: incremental\n-   The **prediction likelihood** $\\pi(\\tilde{Y} \\mid \\Theta, y)$ depends on the task:\n    -   extrapolation(e.g. forecasting of an AR(1)): $\\pi(Y_{n+1} \\mid \\Theta, y_n)$,\n    -   **interporlation**: $\\pi(Y_i \\mid y_{i-1}, y_{i+1}, \\Theta)$,\n-   Spatial prediction fits naturally into this framework:\n    -   $\\tilde{Y}$ may represent $Z(s_0)$, $\\eta_0$, or the response at $y(s_0)$,\n    -   conditioning reflects the assumed spatial dependence.\n-   INLA approximates $\\pi(\\Theta \\mid y)$ efficiently, enabling **full uncertainty propagation** when predicting over $s_0 \\in \\mathcal{D}$.\n:::\n\n## Posterior predictive density {.smaller auto-animate=\"true\" background-color=\"#FFFFFF\"}\n\n::::: columns\n::: {.column width=\"40%\"}\n**Step 0 — Augment the data with prediction locations**\n\n-   Introduce locations where predictions are desired.\n\n-   The response is set to `NA` at these locations.\n\n-   Covariates and spatial coordinates are still provided.\n\n**Step 1 — Build the projector matrix A**\n\n**Step 2 — Joint posterior inference**\n\n**Step 3 — Posterior evaluation at prediction locations**\n:::\n\n::: {.column width=\"60%\"}\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndims = c(150, 150)\npred.df <- fm_pixels(mesh,dims = dims,mask =border,  format = \"sf\")\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](slides_8_files/figure-revealjs/unnamed-chunk-24-1.png){fig-align='center' width=60%}\n:::\n:::\n\n\n\n:::\n:::::\n\n## Posterior predictive density {.smaller auto-animate=\"true\" background-color=\"#FFFFFF\"}\n\n::::: columns\n::: {.column width=\"40%\"}\n**Step 0 — Augment the data with prediction locations**\n\n**Step 1 — Build the projector matrix A**\n\n-   A projector matrix $A$ linking the latent Gaussian field to the prediction locations.\n\n-   This ensures that the spatial effects and covariates at new locations are properly included in the model.\n\n-   Linear predictors are computed at these new locations\n\n**Step 2 — Joint posterior inference**\n\n**Step 3 — Posterior evaluation at prediction locations**\n:::\n\n::: {.column width=\"60%\"}\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npred <- predict(fit,pred.df,\n                formula ~ data.frame(\n    spde =  space,\n    eta = Intercept + space\n  )\n)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n\n:::\n:::::\n\n## Posterior predictive density {.smaller auto-animate=\"true\" background-color=\"#FFFFFF\"}\n\n::::: columns\n::: {.column width=\"40%\"}\n**Step 0 — Augment the data with prediction locations**\n\n**Step 1 — Build the projector matrix A**\n\n**Step 2 — Joint posterior inference**\n\n-   INLA computes the posterior of:\n\n    -   the latent Gaussian field,\n\n    -   fixed effects,\n\n    -   hyperparameters.\n\n**Step 3 — Posterior evaluation at prediction locations**\n:::\n\n::: {.column width=\"60%\"}\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npred <- predict(fit,pred.df,\n                formula ~ data.frame(\n    spde =  space,\n    eta = Intercept + space\n  )\n)\n```\n:::\n\n\n\n:::\n:::::\n\n## Posterior predictive density {.smaller auto-animate=\"true\" background-color=\"#FFFFFF\"}\n\n::::: columns\n::: {.column width=\"40%\"}\n**Step 0 — Augment the data with prediction locations**\n\n**Step 1 — Build the projector matrix A**\n\n**Step 2 — Joint posterior inference**\n\n**Step 3 — Posterior evaluation at prediction locations**\n\n-   Predictions come from the posterior marginals of the latent field and linear predictor.\n\n-   Outputs include posterior means, variances, and credible intervals.\n:::\n\n::: {.column width=\"60%\"}\n![](figures/parana_pred2.png){fig-align=\"center\" width=\"324\"}\n:::\n:::::\n\n# Modelling Pacific Cod Biomass Density {background-image=\"cod.jpg\"}\n\n## Example: Modelling Pacific Cod Biomass Density {background-color=\"#FFFFFF\"}\n\nIn the next example, we will explore data on the Pacific Cod (*Gadus macrocephalus*) from a trawl survey in Queen Charlotte Sound.\n\n-   The dataset the biomass density (kg/km$^2$) of Pacific cod in the area swept for a given survey in 2003 as well as depth covariate information.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](slides_8_files/figure-revealjs/unnamed-chunk-28-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n\n## Exploratory plots {.smaller background-color=\"#FFFFFF\" auto-animate=\"true\"}\n\n::::: columns\n::: {.column width=\"50%\"}\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](slides_8_files/figure-revealjs/unnamed-chunk-29-1.png){fig-align='center' width=60%}\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"50%\"}\nEnvelope Variogram considering only where biomass $>$ 0\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](slides_8_files/figure-revealjs/unnamed-chunk-30-1.png){fig-align='center' width=60%}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"There are 2 out of 15 variogram estimates outside the 95% envelope.\"\n```\n\n\n:::\n:::\n\n\n\n:::\n:::::\n\n## Exploratory plots {.smaller background-color=\"#FFFFFF\" auto-animate=\"true\"}\n\n::::: columns\n::: {.column width=\"40%\"}\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](slides_8_files/figure-revealjs/unnamed-chunk-31-1.png){fig-align='center' width=60%}\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"60%\"}\nEnvelope Variogram considering only where biomass $>$ 0\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](slides_8_files/figure-revealjs/unnamed-chunk-32-1.png){fig-align='center' width=60%}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"There are 2 out of 15 variogram estimates outside the 95% envelope.\"\n```\n\n\n:::\n:::\n\n\n\n:::\n:::::\n\nWe thus have a dilemma.\n\n-   If we omit the zeros, we’ll get a good, accurate model fit for non-zero data, but we’ll be throwing away all the data with zeros\n-   If we include the zeros, we won’t be throwing any data away, but we’ll get a strange-fitting model that both under- and over-predicts values.\n-   So what do we do?\n\n## A non-spatial Model {.smaller auto-animate=\"true\"}\n\n-   [**Stage 1** Model for the response]{style=\"color:#FF6B6B;\"} $$\n    y(s)|\\eta(s)\\sim \\text{Tweedie}(p,\\mu_i,\\phi)\n    $$\n\n    -   Tweedie account for positive continuous density values that also contain zeros\n\n    -   $p$ determines the shape of the variance function (shifts from a Poisson distribution at $p=1$ to a gamma distribution at $p=2$)\n\n    -   $\\mu(s) = \\exp ⁡\\eta (i)$ is the mean linked to linear predictor by the log link.\n\n    -   $\\phi$ = dispersion parameter .\n\n-   **Stage 2** Latent field model $$\n    \\eta(s) = \\text{log}(\\mu(s)) = \\beta_0 + \\beta_1 \\text{depth} + \\beta_2 \\text{depth}^2\n    $$\n\n-   **Stage 3** Hyperparameters\n\n## A non-spatial Model {.smaller auto-animate=\"true\"}\n\n-   **Stage 1** Model for the response$$\n    y(s)|\\eta(s)\\sim \\text{Tweedie}(p,\\mu_i,\\phi)\n    $$\n-   [**Stage 2** Latent field model]{style=\"color:#FF6B6B;\"} $$\n    \\eta(s) = \\exp(\\mu(s)) = \\beta_0 + \\beta_1 x(s) + \\beta_2 x(s)^2\n    $$\n    -   A global intercept $\\beta_0$\n    -   A effect of covariate $x(s)$ (depth)\n    -   A quadratic effect of covariate $x(s)$ (depth)\n-   **Stage 3** Hyperparameters\n\n## A non-spatial Model {.smaller auto-animate=\"true\"}\n\n-   **Stage 1** Model for the response $$\n    y(s)|\\eta(s)\\sim \\text{Tweedie}(p,\\mu_i,\\phi)\n    $$\n\n-   **Stage 2** Latent field model$$\n    \\eta(s) = \\exp(\\mu(s)) = \\beta_0 + \\beta_1 x(s) + \\beta_2 x(s)^2\n    $$\n\n-   [**Stage 3** Hyperparameters]{style=\"color:#FF6B6B;\"}\n\n    -   dispersion parameter $\\phi$\n    -   power parameter $p$\n\n## A non-spatial Model {.smaller auto-animate=\"true\"}\n\n::::: columns\n::: {.column width=\"40%\"}\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"vpazahrtxj\" style=\"padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n<style>#vpazahrtxj table {\n  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n#vpazahrtxj thead, #vpazahrtxj tbody, #vpazahrtxj tfoot, #vpazahrtxj tr, #vpazahrtxj td, #vpazahrtxj th {\n  border-style: none;\n}\n\n#vpazahrtxj p {\n  margin: 0;\n  padding: 0;\n}\n\n#vpazahrtxj .gt_table {\n  display: table;\n  border-collapse: collapse;\n  line-height: normal;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#vpazahrtxj .gt_caption {\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n\n#vpazahrtxj .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#vpazahrtxj .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 3px;\n  padding-bottom: 5px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#vpazahrtxj .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#vpazahrtxj .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#vpazahrtxj .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#vpazahrtxj .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#vpazahrtxj .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#vpazahrtxj .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#vpazahrtxj .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#vpazahrtxj .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#vpazahrtxj .gt_spanner_row {\n  border-bottom-style: hidden;\n}\n\n#vpazahrtxj .gt_group_heading {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  text-align: left;\n}\n\n#vpazahrtxj .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#vpazahrtxj .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#vpazahrtxj .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#vpazahrtxj .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#vpazahrtxj .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#vpazahrtxj .gt_stub_row_group {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n  vertical-align: top;\n}\n\n#vpazahrtxj .gt_row_group_first td {\n  border-top-width: 2px;\n}\n\n#vpazahrtxj .gt_row_group_first th {\n  border-top-width: 2px;\n}\n\n#vpazahrtxj .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#vpazahrtxj .gt_first_summary_row {\n  border-top-style: solid;\n  border-top-color: #D3D3D3;\n}\n\n#vpazahrtxj .gt_first_summary_row.thick {\n  border-top-width: 2px;\n}\n\n#vpazahrtxj .gt_last_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#vpazahrtxj .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#vpazahrtxj .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#vpazahrtxj .gt_last_grand_summary_row_top {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: double;\n  border-bottom-width: 6px;\n  border-bottom-color: #D3D3D3;\n}\n\n#vpazahrtxj .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#vpazahrtxj .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#vpazahrtxj .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#vpazahrtxj .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#vpazahrtxj .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#vpazahrtxj .gt_sourcenote {\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#vpazahrtxj .gt_left {\n  text-align: left;\n}\n\n#vpazahrtxj .gt_center {\n  text-align: center;\n}\n\n#vpazahrtxj .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#vpazahrtxj .gt_font_normal {\n  font-weight: normal;\n}\n\n#vpazahrtxj .gt_font_bold {\n  font-weight: bold;\n}\n\n#vpazahrtxj .gt_font_italic {\n  font-style: italic;\n}\n\n#vpazahrtxj .gt_super {\n  font-size: 65%;\n}\n\n#vpazahrtxj .gt_footnote_marks {\n  font-size: 75%;\n  vertical-align: 0.4em;\n  position: initial;\n}\n\n#vpazahrtxj .gt_asterisk {\n  font-size: 100%;\n  vertical-align: 0;\n}\n\n#vpazahrtxj .gt_indent_1 {\n  text-indent: 5px;\n}\n\n#vpazahrtxj .gt_indent_2 {\n  text-indent: 10px;\n}\n\n#vpazahrtxj .gt_indent_3 {\n  text-indent: 15px;\n}\n\n#vpazahrtxj .gt_indent_4 {\n  text-indent: 20px;\n}\n\n#vpazahrtxj .gt_indent_5 {\n  text-indent: 25px;\n}\n\n#vpazahrtxj .katex-display {\n  display: inline-flex !important;\n  margin-bottom: 0.75em !important;\n}\n\n#vpazahrtxj div.Reactable > div.rt-table > div.rt-thead > div.rt-tr.rt-tr-group-header > div.rt-th-group:after {\n  height: 0px !important;\n}\n</style>\n<table class=\"gt_table\" data-quarto-disable-processing=\"false\" data-quarto-bootstrap=\"false\">\n  <thead>\n    <tr class=\"gt_heading\">\n      <td colspan=\"4\" class=\"gt_heading gt_title gt_font_normal\" style>INLA Model Results</td>\n    </tr>\n    <tr class=\"gt_heading\">\n      <td colspan=\"4\" class=\"gt_heading gt_subtitle gt_font_normal gt_bottom_border\" style>Posterior summaries of fixed effects and hyperparameters</td>\n    </tr>\n    <tr class=\"gt_col_headings\">\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"a::stub\">Parameter</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"mean\">Mean</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"a0.025quant\">2.5% Quantile</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"a0.975quant\">97.5% Quantile</th>\n    </tr>\n  </thead>\n  <tbody class=\"gt_table_body\">\n    <tr><th id=\"stub_1_1\" scope=\"row\" class=\"gt_row gt_left gt_stub\">Intercept</th>\n<td headers=\"stub_1_1 mean\" class=\"gt_row gt_right\">3.866</td>\n<td headers=\"stub_1_1 0.025quant\" class=\"gt_row gt_right\">3.690</td>\n<td headers=\"stub_1_1 0.975quant\" class=\"gt_row gt_right\">4.043</td></tr>\n    <tr><th id=\"stub_1_2\" scope=\"row\" class=\"gt_row gt_left gt_stub\">depth</th>\n<td headers=\"stub_1_2 mean\" class=\"gt_row gt_right\">−1.269</td>\n<td headers=\"stub_1_2 0.025quant\" class=\"gt_row gt_right\">−1.480</td>\n<td headers=\"stub_1_2 0.975quant\" class=\"gt_row gt_right\">−1.059</td></tr>\n    <tr><th id=\"stub_1_3\" scope=\"row\" class=\"gt_row gt_left gt_stub\">depth2</th>\n<td headers=\"stub_1_3 mean\" class=\"gt_row gt_right\">−1.077</td>\n<td headers=\"stub_1_3 0.025quant\" class=\"gt_row gt_right\">−1.256</td>\n<td headers=\"stub_1_3 0.975quant\" class=\"gt_row gt_right\">−0.898</td></tr>\n    <tr><th id=\"stub_1_4\" scope=\"row\" class=\"gt_row gt_left gt_stub\">p parameter for Tweedie</th>\n<td headers=\"stub_1_4 mean\" class=\"gt_row gt_right\">1.643</td>\n<td headers=\"stub_1_4 0.025quant\" class=\"gt_row gt_right\">1.617</td>\n<td headers=\"stub_1_4 0.975quant\" class=\"gt_row gt_right\">1.668</td></tr>\n    <tr><th id=\"stub_1_5\" scope=\"row\" class=\"gt_row gt_left gt_stub\">Dispersion parameter for Tweedie</th>\n<td headers=\"stub_1_5 mean\" class=\"gt_row gt_right\">3.804</td>\n<td headers=\"stub_1_5 0.025quant\" class=\"gt_row gt_right\">3.530</td>\n<td headers=\"stub_1_5 0.975quant\" class=\"gt_row gt_right\">4.093</td></tr>\n  </tbody>\n  \n</table>\n</div>\n```\n\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"60%\"}\n-   $\\beta$ coef suggest log-biomass peaks at an intermediate depth within the study range and decreases toward both shallower and deeper extremes.\n-   $\\phi>1$ indicates overdispersion relative to the variance function. Potentially caused by Unobserved heterogeneity.\n-   Tweedie models fitted to biomass usually have convergence issues when there are large spatial areas with many zeros.\n-   Is there a better approach?\n:::\n:::::\n\n## A multilikelihood Hurdle Geostatistical Model {.smaller auto-animate=\"true\"}\n\n-   [**Stage 1** Model for the response(s)]{style=\"color:#FF6B6B;\"} $$\n    \\begin{aligned}\n    y_i|\\eta^{(1)}_i&\\sim \\text{Binomial}(1,\\pi_i)\\\\\n    \\log(z_i)|\\eta^{(2)}_i&\\sim \\text{Normal}(\\mu_i,\\tau_e^{-1})\\\\\n    \\end{aligned}\n    $$\n\n    -   We then define a likelihood for each outcome.\n\n        -   $y_i =\\begin{cases} 1 &\\text{if fishes have been caught at location } \\mathbf{s}_i  \\\\ 0 &\\text{otherwise}\\end{cases}$\n\n        -   $z_i =\\begin{cases} NA &\\text{if no fish were  caught at location } \\mathbf{s}_i  \\\\ \\text{biomass density at location } \\mathbf{s}_i &\\text{otherwise}\\end{cases}$\n\n-   **Stage 2** Latent field model $$\n    \\begin{aligned}\n    \\eta^{(1)}_i &= \\text{logit}(\\pi_i) = X'\\beta + \\xi_i\\\\\n    \\eta^{(2)}_i &= \\mu_i = X'\\alpha + \\omega_i\n    \\end{aligned}\n    $$\n\n-   **Stage 3** Hyperparameters\n\n## A multilikelihood Hurdle Geostatistical Model {.smaller auto-animate=\"true\"}\n\n-   **Stage 1** Model for the response(s)\\] $$\n    \\begin{aligned}\n    y_i|\\eta^{(1)}_i&\\sim \\text{Binomial}(1,\\pi_i)\\\\\n    \\log(z_i)|\\eta^{(2)}_i&\\sim \\text{Normal}(\\mu_i,\\tau_e^{-1})\\\\\n    \\end{aligned}\n    $$\n-   [**Stage 2** Latent field model]{style=\"color:#FF6B6B;\"} $$\n    \\begin{aligned}\n    \\eta^{(1)}_i &= \\text{logit}(\\pi_i) = X'\\beta + \\xi_i\\\\\n    \\eta^{(2)}_i &= \\mu_i = X'\\alpha + \\omega_i\n    \\end{aligned}\n    $$\n    -   $\\{\\alpha,\\beta\\}$ = Intercepts + covariate effects.\n    -   $\\{\\xi,\\omega\\}$ = are the Gaussian fields with Matérn covariance (separate for each outcome).\n-   **Stage 3** Hyperparameters\n\n## A multilikelihood Hurdle Geostatistical Model {.smaller auto-animate=\"true\"}\n\n-   **Stage 1** Model for the response(s) $$\n    \\begin{aligned}\n    y_i|\\eta^{(1)}_i&\\sim \\text{Binomial}(1,\\pi_i)\\\\\n    \\log(z_i)|\\eta^{(2)}_i&\\sim \\text{Normal}(\\mu_i,\\tau_e^{-1})\\\\\n    \\end{aligned}\n    $$\n\n-   **Stage 2** Latent field model $$\n    \\begin{aligned}\n    \\eta^{(1)}_i &= \\text{logit}(\\pi_i) = X'\\beta + \\xi_i\\\\\n    \\eta^{(2)}_i &= \\mu_i = X'\\alpha + \\omega_i\n    \\end{aligned}\n    $$\n\n-   [**Stage 3** Hyperparameters]{style=\"color:#FF6B6B;\"}\n\n    -   observational error (nugget) $\\tau_e$\n    -   Matérn field(s) parameters $\\{\\rho^{(1)},\\rho^{(2)},\\tau_{d}^{(1)},\\tau_{d}^{(2)}\\}$\n\n## The mesh and SPDE representation\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](slides_8_files/figure-revealjs/unnamed-chunk-34-1.png){fig-align='center' width=60%}\n:::\n:::\n\n\n\n\n## Hurdle Model Results {.smaller auto-animate=\"true\" background-color=\"#FFFFFF\"}\n\n:::::: columns\n::: {.column width=\"40%\"}\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"vhyiqpkdqu\" style=\"padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n<style>#vhyiqpkdqu table {\n  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n#vhyiqpkdqu thead, #vhyiqpkdqu tbody, #vhyiqpkdqu tfoot, #vhyiqpkdqu tr, #vhyiqpkdqu td, #vhyiqpkdqu th {\n  border-style: none;\n}\n\n#vhyiqpkdqu p {\n  margin: 0;\n  padding: 0;\n}\n\n#vhyiqpkdqu .gt_table {\n  display: table;\n  border-collapse: collapse;\n  line-height: normal;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 50%;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#vhyiqpkdqu .gt_caption {\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n\n#vhyiqpkdqu .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 3px;\n  padding-bottom: 3px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#vhyiqpkdqu .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 2px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#vhyiqpkdqu .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#vhyiqpkdqu .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#vhyiqpkdqu .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#vhyiqpkdqu .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 3px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#vhyiqpkdqu .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#vhyiqpkdqu .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#vhyiqpkdqu .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#vhyiqpkdqu .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 3px;\n  padding-bottom: 3px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#vhyiqpkdqu .gt_spanner_row {\n  border-bottom-style: hidden;\n}\n\n#vhyiqpkdqu .gt_group_heading {\n  padding-top: 3px;\n  padding-bottom: 3px;\n  padding-left: 5px;\n  padding-right: 5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  text-align: left;\n}\n\n#vhyiqpkdqu .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#vhyiqpkdqu .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#vhyiqpkdqu .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#vhyiqpkdqu .gt_row {\n  padding-top: 3px;\n  padding-bottom: 3px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#vhyiqpkdqu .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#vhyiqpkdqu .gt_stub_row_group {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n  vertical-align: top;\n}\n\n#vhyiqpkdqu .gt_row_group_first td {\n  border-top-width: 2px;\n}\n\n#vhyiqpkdqu .gt_row_group_first th {\n  border-top-width: 2px;\n}\n\n#vhyiqpkdqu .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#vhyiqpkdqu .gt_first_summary_row {\n  border-top-style: solid;\n  border-top-color: #D3D3D3;\n}\n\n#vhyiqpkdqu .gt_first_summary_row.thick {\n  border-top-width: 2px;\n}\n\n#vhyiqpkdqu .gt_last_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#vhyiqpkdqu .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#vhyiqpkdqu .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#vhyiqpkdqu .gt_last_grand_summary_row_top {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: double;\n  border-bottom-width: 6px;\n  border-bottom-color: #D3D3D3;\n}\n\n#vhyiqpkdqu .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#vhyiqpkdqu .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#vhyiqpkdqu .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#vhyiqpkdqu .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#vhyiqpkdqu .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#vhyiqpkdqu .gt_sourcenote {\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#vhyiqpkdqu .gt_left {\n  text-align: left;\n}\n\n#vhyiqpkdqu .gt_center {\n  text-align: center;\n}\n\n#vhyiqpkdqu .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#vhyiqpkdqu .gt_font_normal {\n  font-weight: normal;\n}\n\n#vhyiqpkdqu .gt_font_bold {\n  font-weight: bold;\n}\n\n#vhyiqpkdqu .gt_font_italic {\n  font-style: italic;\n}\n\n#vhyiqpkdqu .gt_super {\n  font-size: 65%;\n}\n\n#vhyiqpkdqu .gt_footnote_marks {\n  font-size: 75%;\n  vertical-align: 0.4em;\n  position: initial;\n}\n\n#vhyiqpkdqu .gt_asterisk {\n  font-size: 100%;\n  vertical-align: 0;\n}\n\n#vhyiqpkdqu .gt_indent_1 {\n  text-indent: 5px;\n}\n\n#vhyiqpkdqu .gt_indent_2 {\n  text-indent: 10px;\n}\n\n#vhyiqpkdqu .gt_indent_3 {\n  text-indent: 15px;\n}\n\n#vhyiqpkdqu .gt_indent_4 {\n  text-indent: 20px;\n}\n\n#vhyiqpkdqu .gt_indent_5 {\n  text-indent: 25px;\n}\n\n#vhyiqpkdqu .katex-display {\n  display: inline-flex !important;\n  margin-bottom: 0.75em !important;\n}\n\n#vhyiqpkdqu div.Reactable > div.rt-table > div.rt-thead > div.rt-tr.rt-tr-group-header > div.rt-th-group:after {\n  height: 0px !important;\n}\n</style>\n<table class=\"gt_table\" data-quarto-disable-processing=\"false\" data-quarto-bootstrap=\"false\">\n  <thead>\n    <tr class=\"gt_col_headings\">\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"a::stub\">Parameter</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"mean\">Mean</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"a0.025quant\">2.5% Quantile</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"a0.975quant\">97.5% Quantile</th>\n    </tr>\n  </thead>\n  <tbody class=\"gt_table_body\">\n    <tr><th id=\"stub_1_1\" scope=\"row\" class=\"gt_row gt_left gt_stub\"><span data-qmd-base64=\"JCRcYWxwaGFfMCQk\"><span class='gt_from_md'>$$\\alpha_0$$</span></span></th>\n<td headers=\"stub_1_1 mean\" class=\"gt_row gt_right\">3.498</td>\n<td headers=\"stub_1_1 0.025quant\" class=\"gt_row gt_right\">2.885</td>\n<td headers=\"stub_1_1 0.975quant\" class=\"gt_row gt_right\">4.227</td></tr>\n    <tr><th id=\"stub_1_2\" scope=\"row\" class=\"gt_row gt_left gt_stub\"><span data-qmd-base64=\"JCRcYWxwaGFfMSQk\"><span class='gt_from_md'>$$\\alpha_1$$</span></span></th>\n<td headers=\"stub_1_2 mean\" class=\"gt_row gt_right\">−0.509</td>\n<td headers=\"stub_1_2 0.025quant\" class=\"gt_row gt_right\">−1.098</td>\n<td headers=\"stub_1_2 0.975quant\" class=\"gt_row gt_right\">0.059</td></tr>\n    <tr><th id=\"stub_1_3\" scope=\"row\" class=\"gt_row gt_left gt_stub\"><span data-qmd-base64=\"JCRcYWxwaGFfMiQk\"><span class='gt_from_md'>$$\\alpha_2$$</span></span></th>\n<td headers=\"stub_1_3 mean\" class=\"gt_row gt_right\">−0.339</td>\n<td headers=\"stub_1_3 0.025quant\" class=\"gt_row gt_right\">−0.789</td>\n<td headers=\"stub_1_3 0.975quant\" class=\"gt_row gt_right\">0.106</td></tr>\n    <tr><th id=\"stub_1_4\" scope=\"row\" class=\"gt_row gt_left gt_stub\"><span data-qmd-base64=\"JCRcYmV0YV8wJCQ=\"><span class='gt_from_md'>$$\\beta_0$$</span></span></th>\n<td headers=\"stub_1_4 mean\" class=\"gt_row gt_right\">1.761</td>\n<td headers=\"stub_1_4 0.025quant\" class=\"gt_row gt_right\">−3.215</td>\n<td headers=\"stub_1_4 0.975quant\" class=\"gt_row gt_right\">7.267</td></tr>\n    <tr><th id=\"stub_1_5\" scope=\"row\" class=\"gt_row gt_left gt_stub\"><span data-qmd-base64=\"JCRcYmV0YV8xJCQ=\"><span class='gt_from_md'>$$\\beta_1$$</span></span></th>\n<td headers=\"stub_1_5 mean\" class=\"gt_row gt_right\">−2.564</td>\n<td headers=\"stub_1_5 0.025quant\" class=\"gt_row gt_right\">−3.626</td>\n<td headers=\"stub_1_5 0.975quant\" class=\"gt_row gt_right\">−1.694</td></tr>\n    <tr><th id=\"stub_1_6\" scope=\"row\" class=\"gt_row gt_left gt_stub\"><span data-qmd-base64=\"JCRcYmV0YV8yJCQ=\"><span class='gt_from_md'>$$\\beta_2$$</span></span></th>\n<td headers=\"stub_1_6 mean\" class=\"gt_row gt_right\">−1.495</td>\n<td headers=\"stub_1_6 0.025quant\" class=\"gt_row gt_right\">−2.143</td>\n<td headers=\"stub_1_6 0.975quant\" class=\"gt_row gt_right\">−0.944</td></tr>\n    <tr><th id=\"stub_1_7\" scope=\"row\" class=\"gt_row gt_left gt_stub\"><span data-qmd-base64=\"JCRcdGF1X1xlcHNpbG9uXjIkJA==\"><span class='gt_from_md'>$$\\tau_\\epsilon^2$$</span></span></th>\n<td headers=\"stub_1_7 mean\" class=\"gt_row gt_right\">1.152</td>\n<td headers=\"stub_1_7 0.025quant\" class=\"gt_row gt_right\">0.464</td>\n<td headers=\"stub_1_7 0.975quant\" class=\"gt_row gt_right\">2.575</td></tr>\n    <tr><th id=\"stub_1_8\" scope=\"row\" class=\"gt_row gt_left gt_stub\"><span data-qmd-base64=\"JCRccmhvXntbMV19JCQ=\"><span class='gt_from_md'>$$\\rho^{[1]}$$</span></span></th>\n<td headers=\"stub_1_8 mean\" class=\"gt_row gt_right\">36.647</td>\n<td headers=\"stub_1_8 0.025quant\" class=\"gt_row gt_right\">6.874</td>\n<td headers=\"stub_1_8 0.975quant\" class=\"gt_row gt_right\">103.820</td></tr>\n    <tr><th id=\"stub_1_9\" scope=\"row\" class=\"gt_row gt_left gt_stub\"><span data-qmd-base64=\"JCRcdGF1X3tkLDF9JCQ=\"><span class='gt_from_md'>$$\\tau_{d,1}$$</span></span></th>\n<td headers=\"stub_1_9 mean\" class=\"gt_row gt_right\">1.001</td>\n<td headers=\"stub_1_9 0.025quant\" class=\"gt_row gt_right\">0.571</td>\n<td headers=\"stub_1_9 0.975quant\" class=\"gt_row gt_right\">1.658</td></tr>\n    <tr><th id=\"stub_1_10\" scope=\"row\" class=\"gt_row gt_left gt_stub\"><span data-qmd-base64=\"JCRccmhvXntbMl19JCQ=\"><span class='gt_from_md'>$$\\rho^{[2]}$$</span></span></th>\n<td headers=\"stub_1_10 mean\" class=\"gt_row gt_right\">158.333</td>\n<td headers=\"stub_1_10 0.025quant\" class=\"gt_row gt_right\">57.011</td>\n<td headers=\"stub_1_10 0.975quant\" class=\"gt_row gt_right\">398.763</td></tr>\n    <tr><th id=\"stub_1_11\" scope=\"row\" class=\"gt_row gt_left gt_stub\"><span data-qmd-base64=\"JCRcdGF1X3tkLDJ9JCQ=\"><span class='gt_from_md'>$$\\tau_{d,2}$$</span></span></th>\n<td headers=\"stub_1_11 mean\" class=\"gt_row gt_right\">2.201</td>\n<td headers=\"stub_1_11 0.025quant\" class=\"gt_row gt_right\">1.192</td>\n<td headers=\"stub_1_11 0.975quant\" class=\"gt_row gt_right\">3.768</td></tr>\n  </tbody>\n  \n</table>\n</div>\n```\n\n:::\n:::\n\n\n\n:::\n\n:::: {.column width=\"60%\"}\n::: {style=\"height: 50px;\"}\n:::\n\n-   $\\alpha_0$ is the baseline catching probability on the logit scale\n-   $\\beta_0$ is the predicted log(biomass density at the average depth (since these have been scaled)\n-   Coefficients $\\alpha_1,\\alpha_2$ refer to the change in the log-odds of catching fish as we increase 1 depth unit and unit$^2$ respectively.\n-   Coefficients $\\beta_1, \\beta_2$ indicate that the log-biomass decreases with depth.\n-   $\\rho^{[1]},\\rho^{[2]}$, suggest spatial correlation decays at 36.65 and 158.33 Km respectively (the extension of the study is approx 46,000 km$^2$)\n-   unstructured variability is given by $\\tau^{-1}_e$ while ,$\\{\\tau_{\\delta,1}^{-1},\\tau^{-1}_{d,2}\\}$ represent the spatially structured variability.\n::::\n::::::\n\n## Model comparison {.smaller}\n\nNote that in the hurdle model there is no direct link between the parameters of the two observation parts.\n\n::: incremental\n-   the two likelihoods could share some of the components; for example the Matérn field could be used for both predictors.\n\n-   What does the previous results suggest in terms of the estimated covariance parameters for the two fields? is it sensible to share the same component between the two parts?\n\n-   We will fit a model that estimates this field jointly and compare it with our two previous models\n:::\n\n::: fragment\nThe model being fitted is now:\n\n$$\n\\begin{aligned}\ny_i|\\eta^{(1)}_i&\\sim \\text{Binomial}(1,\\pi_i)\\\\\n\\eta^{(1)}_i &= \\text{logit}(\\pi_i) = X'\\beta + \\color{red}{\\xi_i}\\\\\n\\log(z_i)|\\eta^{(2)}_i&\\sim \\text{Normal}(\\mu_i,\\tau_e^{-1})\\\\\n\\eta^{(2)}_i &= \\mu_i = X'\\alpha +  \\color{red}{\\xi_i}\n\\end{aligned}\n$$\n:::\n\n## Model comparison {.smaller}\n\nNote that in the hurdle model there is no direct link between the parameters of the two observation parts.\n\n-   the two likelihoods could share some of the components; for example the Matérn field could be used for both predictors.\n\n-   What does the previous results suggest in terms of the estimated covariance parameters for the two fields? is it sensible to share the same component between the two parts?\n\n-   We will fit a model that estimates this field jointly and compare it with our two previous models\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"dhcvvkyprh\" style=\"padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n<style>#dhcvvkyprh table {\n  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n#dhcvvkyprh thead, #dhcvvkyprh tbody, #dhcvvkyprh tfoot, #dhcvvkyprh tr, #dhcvvkyprh td, #dhcvvkyprh th {\n  border-style: none;\n}\n\n#dhcvvkyprh p {\n  margin: 0;\n  padding: 0;\n}\n\n#dhcvvkyprh .gt_table {\n  display: table;\n  border-collapse: collapse;\n  line-height: normal;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#dhcvvkyprh .gt_caption {\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n\n#dhcvvkyprh .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#dhcvvkyprh .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 3px;\n  padding-bottom: 5px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#dhcvvkyprh .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#dhcvvkyprh .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#dhcvvkyprh .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#dhcvvkyprh .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#dhcvvkyprh .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#dhcvvkyprh .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#dhcvvkyprh .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#dhcvvkyprh .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#dhcvvkyprh .gt_spanner_row {\n  border-bottom-style: hidden;\n}\n\n#dhcvvkyprh .gt_group_heading {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  text-align: left;\n}\n\n#dhcvvkyprh .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#dhcvvkyprh .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#dhcvvkyprh .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#dhcvvkyprh .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#dhcvvkyprh .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#dhcvvkyprh .gt_stub_row_group {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n  vertical-align: top;\n}\n\n#dhcvvkyprh .gt_row_group_first td {\n  border-top-width: 2px;\n}\n\n#dhcvvkyprh .gt_row_group_first th {\n  border-top-width: 2px;\n}\n\n#dhcvvkyprh .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#dhcvvkyprh .gt_first_summary_row {\n  border-top-style: solid;\n  border-top-color: #D3D3D3;\n}\n\n#dhcvvkyprh .gt_first_summary_row.thick {\n  border-top-width: 2px;\n}\n\n#dhcvvkyprh .gt_last_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#dhcvvkyprh .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#dhcvvkyprh .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#dhcvvkyprh .gt_last_grand_summary_row_top {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: double;\n  border-bottom-width: 6px;\n  border-bottom-color: #D3D3D3;\n}\n\n#dhcvvkyprh .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#dhcvvkyprh .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#dhcvvkyprh .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#dhcvvkyprh .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#dhcvvkyprh .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#dhcvvkyprh .gt_sourcenote {\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#dhcvvkyprh .gt_left {\n  text-align: left;\n}\n\n#dhcvvkyprh .gt_center {\n  text-align: center;\n}\n\n#dhcvvkyprh .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#dhcvvkyprh .gt_font_normal {\n  font-weight: normal;\n}\n\n#dhcvvkyprh .gt_font_bold {\n  font-weight: bold;\n}\n\n#dhcvvkyprh .gt_font_italic {\n  font-style: italic;\n}\n\n#dhcvvkyprh .gt_super {\n  font-size: 65%;\n}\n\n#dhcvvkyprh .gt_footnote_marks {\n  font-size: 75%;\n  vertical-align: 0.4em;\n  position: initial;\n}\n\n#dhcvvkyprh .gt_asterisk {\n  font-size: 100%;\n  vertical-align: 0;\n}\n\n#dhcvvkyprh .gt_indent_1 {\n  text-indent: 5px;\n}\n\n#dhcvvkyprh .gt_indent_2 {\n  text-indent: 10px;\n}\n\n#dhcvvkyprh .gt_indent_3 {\n  text-indent: 15px;\n}\n\n#dhcvvkyprh .gt_indent_4 {\n  text-indent: 20px;\n}\n\n#dhcvvkyprh .gt_indent_5 {\n  text-indent: 25px;\n}\n\n#dhcvvkyprh .katex-display {\n  display: inline-flex !important;\n  margin-bottom: 0.75em !important;\n}\n\n#dhcvvkyprh div.Reactable > div.rt-table > div.rt-thead > div.rt-tr.rt-tr-group-header > div.rt-th-group:after {\n  height: 0px !important;\n}\n</style>\n<table class=\"gt_table\" data-quarto-disable-processing=\"false\" data-quarto-bootstrap=\"false\">\n  <thead>\n    <tr class=\"gt_col_headings\">\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"Model\">Model</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"DIC\">DIC</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"WAIC\">WAIC</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"MLIK\">MLIK</th>\n    </tr>\n  </thead>\n  <tbody class=\"gt_table_body\">\n    <tr><td headers=\"Model\" class=\"gt_row gt_left\">Tweedie</td>\n<td headers=\"DIC\" class=\"gt_row gt_right\">1,599.690</td>\n<td headers=\"WAIC\" class=\"gt_row gt_right\">1,612.043</td>\n<td headers=\"MLIK\" class=\"gt_row gt_right\">−979.532</td></tr>\n    <tr><td headers=\"Model\" class=\"gt_row gt_left\">Hurdle</td>\n<td headers=\"DIC\" class=\"gt_row gt_right\">1,185.793</td>\n<td headers=\"WAIC\" class=\"gt_row gt_right\">1,200.690</td>\n<td headers=\"MLIK\" class=\"gt_row gt_right\">−660.936</td></tr>\n    <tr><td headers=\"Model\" class=\"gt_row gt_left\">Hurdle 2</td>\n<td headers=\"DIC\" class=\"gt_row gt_right\">1,227.128</td>\n<td headers=\"WAIC\" class=\"gt_row gt_right\">1,227.340</td>\n<td headers=\"MLIK\" class=\"gt_row gt_right\">−666.295</td></tr>\n  </tbody>\n  \n</table>\n</div>\n```\n\n:::\n:::\n\n\n\n\n## Spatial predictions {.smaller background-color=\"#FFFFFF\"}\n\n::::: columns\n::: {.column width=\"40%\"}\nWe need to compute:\n\n-   $\\pi(s)$ = Catching probability\n\n-   $\\mathbb{E}[Z(s)|Y(s)] = \\exp\\left(\\mu(s) + \\dfrac{1}{2\\tau_{e}}\\right)$\n\n-   $\\mathbb{E}(Z(s)) =\\pi(s)\\times \\mathbb{E}[Z(s)|Y(s)]$\n:::\n\n::: {.column width=\"50%\"}\n![](figures/predictions_hurdle.png){fig-align=\"center\" width=\"547\"}\n:::\n:::::\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n",
    "supporting": [
      "slides_8_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}