<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Modelling Environmental Extremes – Module 2</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-b53751a350365c71b6c909e95f209ed1.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-d976503a77e3cc1e05540cf55dea42ea.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark-4127622b2b65deacbfc6fc4bd5f4cca7.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<meta name="shinylive:serviceworker_dir" content="..">
<script src="../site_libs/quarto-contrib/shinylive-0.9.1/shinylive/load-shinylive-sw.js" type="module"></script>
<script src="../site_libs/quarto-contrib/shinylive-0.9.1/shinylive/run-python-blocks.js" type="module"></script>
<link href="../site_libs/quarto-contrib/shinylive-0.9.1/shinylive/shinylive.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/shinylive-quarto-css/shinylive-quarto.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/bootstrap-icons-1.13.1/bootstrap-icons.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
<link rel="stylesheet" href="../include/webex.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../UofG.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Module 2</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-notes" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Notes</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-notes">    
        <li>
    <a class="dropdown-item" href="../notes/notes_1.html">
 <span class="dropdown-text">Week 4 - Assessing Change Over Time</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../notes/notes_2.html">
 <span class="dropdown-text">Week 5 - Autocorrelation &amp; Changepoints</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../notes/notes_3.html">
 <span class="dropdown-text">Week 6- Modelling Extremes</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-slides" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Slides</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-slides">    
        <li>
    <a class="dropdown-item" href="../slides/Week_4.pdf">
 <span class="dropdown-text">Week 4 - Assessing Change Over Time</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../slides/Week_5.pdf">
 <span class="dropdown-text">Week 5 - Autocorrelation &amp; Changepoints</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../slides/Week 6_2425.pdf">
 <span class="dropdown-text">Week 6 - Modelling Extremes</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#extreme-value-distributions" id="toc-extreme-value-distributions" class="nav-link" data-scroll-target="#extreme-value-distributions">Extreme Value Distributions</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Modelling Environmental Extremes</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="overview" class="level1">
<h1>Overview</h1>
<p>We might want to know more about the maxima and minima of the environmental system we are modelling. For example, we might want to know how strong to make buildings to deal with earthquakes, how high to build flood defences, or how to prepare for extreme low temperatures.</p>
<p>We are trying to model rare events — by their very definition we won’t have a lot of data on these. The bulk of the data in any statistical distribution will be in the centre. Standard density estimation techniques (eg the normal distribution) work well where the data have the greatest density, but that’s not what we need here. We need to use a statistical model which is good at estimating the tails of our distribution.</p>
</section>
<section id="extreme-value-distributions" class="level1">
<h1>Extreme Value Distributions</h1>
<p>The first thing we have to consider is what actually represents an <em>extreme</em> observation. This will vary depending on the context of the dataset.</p>
<p>A lot of investigation of environmental extremes will focus on time series data. Within time series data, we typically have natural groupings or blocks of observations (days, months, years etc) Therefore a common approach for modelling extremes focuses on the idea of <strong>block maxima</strong> — identifying the maximum (or minimum) value in each block. For example, if we have daily temperature data measured over 100 years, we could look at the highest temperature in each year.</p>
<p>Suppose we have a series of random variables <span class="math inline">\(X_1, \ldots, X_n\)</span>, each with cumulative distribution function <span class="math inline">\(F\)</span>, where <span class="math inline">\(F(x) = \text{P}(X \leq x)\)</span>. We can define the maximum of this set of random variables as <span class="math inline">\(M_n = \max{\{ X_1, \ldots, X_n\}}\)</span>. Then we can show that <span class="math inline">\(\text{P}(M_n \leq x) = P(X_1 \leq x, \ldots X_x \leq x) = \{F(x)\}^n = F^n(x)\)</span>.</p>
<p>This suggests that to understand block maxima (the maximum value in blocks of observations), we might focus on estimating <span class="math inline">\(F^n(x)\)</span>. However, this approach faces two fundamental problems:</p>
<ol type="1">
<li><p><strong>The Estimation Problem</strong> - The true cumulative distribution <span class="math inline">\(F(x)\)</span> is unknown. While we could estimate it from data, small errors in estimating <span class="math inline">\(F(x)\)</span> - especially in the tail where <span class="math inline">\(F(x)\)</span> is close to 1 - are magnified exponentially when raised to the power <span class="math inline">\(n\)</span>. A tiny underestimation of the tail probability can lead to dramatically underestimating <span class="math inline">\(F^n(x)\)</span>.</p></li>
<li><p><strong>The Degeneracy Problem</strong> - Note that as <span class="math inline">\(n \to \infty\)</span> then the value of <span class="math inline">\(F^n(x)\)</span> will be 0 or 1 depending on whether <span class="math inline">\(F(x) &lt;1\)</span> or <span class="math inline">\(F(x)=1\)</span>. This means that the limit distribution of the maxima is a degenerate distribution. In simple terms, if you keep taking more and more samples, the maximum just keeps increasing until it effectively becomes a fixed extreme value, with no interesting variation left to model.</p></li>
</ol>
<p>Instead of trying to estimate <span class="math inline">\(F\)</span> or <span class="math inline">\(F^n\)</span> directly, <strong>Extreme Value Theory</strong> shifts focus to the <strong>limiting distribution of the normalized maximum</strong>. We introduce sequences <span class="math inline">\(a_n &gt; 0\)</span> and <span class="math inline">\(b_n\)</span> to stabilize the maximum as <span class="math inline">\(n\)</span> grows. This is a distribution <span class="math inline">\(G(x)\)</span> such that, for constants, <span class="math inline">\(a_n &gt; 0\)</span> and <span class="math inline">\(b_n\)</span>,</p>
<p><span class="math display">\[\text{P}\left(\frac{M_n - b_n}{a_n} \leq x\right) = F^n(a_n x + b_n) \to G(x) \text{ as } n \to \infty\]</span></p>
<p>There are three main families of extreme value distribution which have our desired properties as limiting distributions of <span class="math inline">\(F^n(x)\)</span>.</p>
<ul>
<li><p><strong>Gumbel</strong>: <span class="math inline">\(G(x) = \exp \left( -\exp [\frac{-(x-a)}{b} ]\right)\)</span></p></li>
<li><p><strong>Frechet</strong>: <span class="math inline">\(G(x) = \exp \left( -[\frac{(x-a)}{b} ]^{-\alpha}\right)\)</span> for <span class="math inline">\(z&gt;b\)</span>, 0 otherwise.</p></li>
<li><p><strong>Weibull</strong>: <span class="math inline">\(G(x) = \exp \left( -[\frac{-(x-a)}{b} ]^{\alpha}\right)\)</span> for <span class="math inline">\(z&gt;b\)</span>, 1 otherwise.</p></li>
</ul>
<p>Here, <span class="math inline">\(a\)</span> is a location parameter, <span class="math inline">\(b\)</span> is a scale parameter and <span class="math inline">\(\alpha\)</span> is a shape parameter.</p>
<p>More generally, we can model the maxima using the Generalised Extreme Value (GEV) distribution <span class="math display">\[G(x) = \exp \left( - \left[ 1 + \frac{\xi (z - \mu)}{\sigma} \right]^{-\frac{1}{\xi}} \right)\]</span></p>
<p>Here, <span class="math inline">\(\mu\)</span> is the location parameter, <span class="math inline">\(\sigma\)</span> is the scale parameter and <span class="math inline">\(\xi\)</span> is the shape parameter. The Gumbel, Frechet and Weibull distributions are all special cases depending on the value of <span class="math inline">\(\xi\)</span>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/GEV.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="427"></p>
</figure>
</div>
<ul>
<li>If <span class="math inline">\(\xi &lt; 0\)</span> then we have the Weibull distribution.</li>
<li>If <span class="math inline">\(\xi &gt; 0\)</span> then we have the Frechet distribution.</li>
<li>As <span class="math inline">\(\xi \to 0\)</span> then we have the Gumbel distribution.</li>
</ul>
<div class="callout callout-style-default callout-important no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<i class="bi-box " style="color: #005C8A;" role="img" aria-hidden="true"></i> Task
</div>
</div>
<div class="callout-body-container callout-body">
<p>Let a random vector <span class="math inline">\(\mathbf{X} = X_1,\ldots,X_n\)</span> such that <span class="math inline">\(\mathbf{X}\overset{iid}{\sim}\mathrm{Uniform}(0,1)\)</span>. Setting the normalizing constants <span class="math inline">\(a_n = 1/n\)</span> and <span class="math inline">\(b_n =1\)</span>, show that the limiting distribution of the maxima <span class="math inline">\(M_n =\mathrm{max}(\mathbf{X})\)</span> as <span class="math inline">\(n\to \infty\)</span> is a GEV with <span class="math inline">\(\mu= -1\)</span> ,<span class="math inline">\(\sigma = 1\)</span> and <span class="math inline">\(\xi = -1\)</span></p>
<div class="webex-solution">
<button>
Take Hint
</button>
<p>Recall that the CDF of an U(0,1) is given by <span class="math inline">\(F(x) = x ~(\text{for } 0 \leq x \leq 1)\)</span>, also note that:</p>
<p><span class="math display">\[
\lim_{n \to \infty}\left( 1 + \frac{1}{n} x\right)^n  = \exp{x}
\]</span></p>
</div>
<div class="webex-solution">
<button>
Solution
</button>
<p><span class="math display">\[
\begin{aligned}
\mathbb{Pr}\left(\dfrac{M_n -b_n}{a_n}\leq x \right) &amp; = \mathbb{Pr}(M_n \leq b_n +a_n x)\\
&amp; = F\left(b_n +a_n x\right)^n\\
&amp;= F\left(1 + \frac{1}{n}x\right)^n\\
&amp; = \left(1 + \frac{1}{n}x\right)^n ~~~\text{for } 0 \leq 1 + x/n   \leq 1 \\
&amp;\rightarrow \exp x~ \text{as }  n \to \infty
\end{aligned}
\]</span> Let <span class="math inline">\(G(x) = \exp \left\{- (1 + \xi \frac{x -\mu}{\sigma})^{-1/xi}\right\}\)</span>, setting <span class="math inline">\(\mu= -1\)</span> ,<span class="math inline">\(\sigma = 1\)</span> and <span class="math inline">\(\xi = -1\)</span></p>
<p><span class="math display">\[
G(x) =  \exp \left\{- (1 -x + 1 )\right\} = \exp x
\]</span></p>
</div>
</div>
</div>
<p>The following app illustrates EVT how the block maxima of a random variable fits a GEV distribution as the sample size increases. The app will generate some samples (blocks) of size <span class="math inline">\(n\)</span> drawn from a specified distribution (Uniform(0,1) or Exp(1)) and plot the distribution (histograms) of the maximum of each sample. Then, it compares the empirical histograms against the theoretical GEV (solid red line). For example, if <span class="math inline">\(X\sim\text{Uniform(0,1)}\)</span> and we standardise the maxima using <span class="math inline">\(b_n=1\)</span> and <span class="math inline">\(a_n=1/n\)</span> the asymptotic distribution of the maxima is a GEV(<span class="math inline">\(\mu=-1,\sigma=1,\xi=-1\)</span>) (see the previous task). Likewise, if <span class="math inline">\(X\sim \exp(1)\)</span> and we let <span class="math inline">\(a_n=1\)</span> and <span class="math inline">\(b_n= \log n\)</span>, the its maxima will converge to a GEV(<span class="math inline">\(\mu=0,\sigma=1,\xi=0\)</span>), i.e., a Gumbell distribution (see the proof in the tutorial material).</p>
<div class="callout callout-style-default callout-important no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<i class="bi-box " style="color: #005C8A;" role="img" aria-hidden="true"></i> Task
</div>
</div>
<div class="callout-body-container callout-body">
<p>Play around with the app settings to see the impact that the number of samples and the size of blocks have on the approximation of the GEV for the different distributions.</p>
</div>
</div>
<pre class="shinylive-r" data-engine="r"><code>#| '!! shinylive warning !!': |
#|   shinylive does not work in self-contained HTML documents.
#|   Please set `embed-resources: false` in your metadata.
#| standalone: true
#| viewerHeight: 500

library(shiny)



# Function to generate block maxima
generate_max &lt;- function(N, n, rdist, param, a, b, seed=pi){
  set.seed(seed)
  Mn &lt;- numeric(N)
  for(i in 1:N){
    sample &lt;- rdist(n, param[1], param[2])
    Mn[i] &lt;- (max(sample) - b) / a
  }
  return(Mn)
}

# UI
iu &lt;- fluidPage(
  titlePanel("Block Maxima Simulation"),
  sidebarLayout(
    sidebarPanel(
      selectInput("dist", "Choose Distribution:", choices = c("Uniform(0,1)" = "uniform", "Exponential(1)" = "exponential")),
      sliderInput("n", "Observations per Block (n):", min = 5, max = 100, value = 5, step = 5),
      sliderInput("N", "Number of Blocks (N):", min = 10000, max = 50000, value = 50000, step = 10000)
    ),
    mainPanel(
      plotOutput("histogram")
    )
  )
)

# Server
server &lt;- function(input, output) {
  output$histogram &lt;- renderPlot({
    if (input$dist == "uniform") {
      a &lt;- 1 / input$n
      b &lt;- 1
      Mn &lt;- generate_max(input$N, input$n, runif, c(0,1), a, b)
      true_gev &lt;- function(x) evd::dgev(x, loc = -1, scale = 1, shape = -1)
    } else {
      a &lt;- 1
      b &lt;- log(input$n)
      Mn &lt;- generate_max(input$N, input$n, rgamma, c(1,1), a, b)
      true_gev &lt;- function(x) evd::dgev(x, loc = 0, scale = 1, shape = 0)
    }
    
    hist(Mn, breaks = "FD", col = "lightblue", prob = TRUE, main = "Histogram of Block Maxima", xlab = "Maxima")
    curve(true_gev, col = "red", lwd = 2, add = TRUE)
  })
}

# Run App
shinyApp(ui = iu, server = server)
</code></pre>
<!-- # Return Levels -->
<!-- Communication of extremes typically focuses on maxima (or minima). Environmental or climate events are often described as the "worst/highest/lowest in X years". -->
<!-- ![](images/EuropeDrought.png){height="250"} ![](images/BangladeshFloods.png){height="250"} -->
<!-- In statistics, this idea of the "highest in X years" can be related to the idea of a **return level** and **return period**. The return level $z_p$ is the value we would expect to be exceeded once every $p$ years, where $\frac{1}{p}$ is the return period. The return level can also be thought of as the value which has probability $\frac{1}{p}$ of being exceeded in a given year. -->
<!-- Now consider the statement "The temperature in Glasgow will reach 20 degrees once every 50 years". -->
<!-- Here, we have return period $\frac{1}{p}=0.02$ and return level $z_p=20$. -->
<!-- The return level $z_p$ is the $(1-\frac{1}{p})$ quantile of the GEV distribution, since we have a probability $\frac{1}{p}$ of the maximum exceeding that value. -->
<!-- Recall that the GEV takes the form $$G(x) = \exp \left( - \left[ 1 + \frac{\xi (z - \mu)}{\sigma} \right]^{-\frac{1}{\xi}} \right)$$ -->
<!-- Therefore the return level can be obtained by inverting this distribution to obtain -->
<!-- $$z_p = \begin{cases} -->
<!--   \mu -  \frac{\sigma}{\xi}\left[ 1 -  \{ - \log(1-\frac{1}{p}) \}^\xi  \right] &  \xi \neq 0\\ -->
<!--   \mu - \sigma \log\{ - \log(1-\frac{1}{p})\}  &  \xi = 0 -->
<!--   \end{cases}$$ -->
<!-- ## Example --- Venice Sea Levels -->
<!-- Sea levels in Venice are rising and the city floods on a regular basis. What sea level can we expect in the next 5, 10, 100 years? -->
<!-- ![](images/GuardianVenice.png){width="500"} -->
<!-- We have daily sea level measurements from 1931-1981. The plot below shows the 10 highest sea level measurements from each year. -->
<!-- ![](images/VeniceData.png){width="500"} -->
<!-- We can apply a block maxima approach, treating each year as a block. This requires us to identify and model the maximum values every year --- highlighted in red. -->
<!-- ![](images/VeniceMax.png){width="500"} -->
<!-- We use the `ismev` package to fit a GEV distribution in R. The `gev.fit()` simply takes a data vector and provides parameter estimates using maximum likelihood estimation. -->
<!-- ```{r, eval=FALSE} -->
<!-- mod1 <- gev.fit(venice) -->
<!-- mod1$mle -->
<!-- ``` -->
<!-- ```          -->
<!-- [1] 111.09925486  17.17548761  -0.07673265 -->
<!-- ``` -->
<!-- From the output we can see that $\mu = 111.1$, $\sigma = 17.2$ and $\xi = -0.077$. -->
<!-- We can assess the suitability of the GEV distribution using a return level plot. This involves commuting the return level at various return periods, and comparing it to the theoretical result under the GEV. -->
<!-- ![](images/ReturnLevelPlot.png){width="500"} -->
<!-- The observed points lie along the theoretical line. Our proposed GEV distribution is appropriate. The Venice maxima follow a Gumbel distribution. -->
<!-- ## Extending Block Maxima --- $k$-largest -->
<!-- Looking at just the maxima means we throw away a lot of data, making it harder to accurately estimate parameters. We could instead follow an approach which models the $k$ largest values within a block. -->
<!-- ![](images/BlockMaximaK.png){width="500"} -->
<!-- We have to make difficult subjective choices when fitting a block maxima model. What do we choose as our block? Week? Month? Year? Decade? Bigger blocks means we have fewer data points, but smaller blocks mean our 'extremes' might not be extreme at all, violating the assumptions of the GEV distribution. If we use a $k$-largest approach, we have a similar decision on what value of $k$ to choose. -->
<!-- Block maxima methods work well in many situations, and take advantage of natural blocks in the data. However, it does not work well if there is a lot of variability between blocks. In that scenario, some blocks may have many more large counts than others, and much of the data will be discarded. We can overcome this by using a threshold approach, which models all observations which exceed some pre-specified value. -->
<!-- # Peak Over Threshold -->
<!-- This approach is known as *peak over threshold (POT)* modelling. Again, we assume we have data represented by a time series, and some threshold $u$. We need a statistical model for the values which are above $u$, known as *exceedances*. Sometimes we may also wish to model the *number* of exceedances. -->
<!-- Again, let $X_1, \ldots, X_n$ be a sequence of independent random variables with a common distribution function $F$. We can consider our extreme values in terms of their **threshold excess** (how much they exceed the threshold by). For an extreme value $X > u$, its threshold excess is given as $y = X - u$. The probability of threshold excess of size $y$ is given by -->
<!-- $$\text{P}(X > u+y|X > u) = \frac{1 - F(u + y)}{1 - F(u)} \hspace{3mm}\text{ where } y > 0.$$ -->
<!-- The function $F$ is still unknown, but the distribution of all threshold excesses can be approximated by a **Generalised Pareto distribution (GPD)**. The cdf of the Generalised Pareto distribution is given by -->
<!-- $$ -->
<!-- G(y) =  -->
<!-- \begin{cases} -->
<!-- 1 - \left( 1 + \frac{\xi (y-\mu)}{\sigma} \right)^{-\frac{1}{\xi}} &  \xi \neq 0\\ -->
<!-- 1 - \exp \left( - \frac{y-\mu}{\sigma} \right)  &  \xi = 0 -->
<!-- \end{cases} -->
<!-- $$ -->
<!-- Again, $\mu$ is the location parameter, $\sigma$ is the scale parameter and $\xi$ is the shape parameter. We can define a return level for POT models in a roughly similar way to block maxima models. The $m$-observation return level, $x_m$ is defined as the level expected to be exceeded once every $m$ observations, with -->
<!-- $$ -->
<!-- x_m =  -->
<!-- \begin{cases} -->
<!-- u + \frac{\sigma}{\xi} \left[ \left(m \text{P}(X>u)\right)^\xi -1 \right] &  \xi \neq 0\\ -->
<!-- u + \sigma \log\left(m \text{P}(X>u)\right) &  \xi = 0 -->
<!-- \end{cases} -->
<!-- $$ -->
<!-- For any given observation, the probability of exceeding $x_m$ is simply $\frac{1}{m}$. -->
<!-- Choosing a threshold is challenging. We need a threshold low enough that we have sufficient data, but high enough that values above it are genuinely extreme. -->
<!-- ![](images/Thresholds.png){width="500"} -->
<!-- Occasionally there is a natural choice of threshold (eg a legal limit for a pollutant), but generally we need to choose it. One approach is to use a **mean residual life plot**, which plots the sample mean excess (mean of $x>u$) at a variety of thresholds $u$. If the GPD is appropriate, the mean excess should be linearly related to the threshold. Therefore, we can identify a suitable threshold as one which lies with an area of linearity on this plot. -->
<!-- ## Example --- Fort Collins, Colorado -->
<!-- We have daily precipitation data from 1900-1999, obtained from a rain gauge in Fort Collins, Colorado, taken from Katz et al, 2002. -->
<!-- ![](images/FortCollinsData.png){width="500"} -->
<!-- We compare three different choices of threshold below ($u = 0.5, 1.0, 1.5$) to show the importance of getting the choice right. -->
<!-- | u   | $\% > u$ | $n > u$ | -->
<!-- |:----|:---------|:--------| -->
<!-- | 0.5 | 2.08     | 759     | -->
<!-- | 1.0 | 0.58     | 213     | -->
<!-- | 1.5 | 0.25     | 91      | -->
<!-- We can fit a mean residual plot to identify a sensible choice of threshold. It appears that a value of $u$ somewhere between 1.2 and 1.8 would be an appropriate choice here --- this is where the plot appears to be linear. -->
<!-- ![](images/MeanResidualPlot.png){width="500"} -->
<!-- We can also carry out a sensitivity analysis to see the effect of choosing different threshold values on the estimated model parameters. The plot below shows the parameter estimates at different thresholds --- they seem fairly robust. -->
<!-- ![](images/Sensitivity.png){width="500"} -->
<!-- We can use the `extRemes` package to fit a Generalised Pareto distribution in R. The function `fevd` allows several extreme value distributions (including GEV and GPD) to be fitted, and can also provide return levels. -->
<!-- ```{r, eval=FALSE} -->
<!-- fitGP <- fevd(Fort, threshold=1.5, type="GP",  -->
<!--                     time.units="365/year") -->
<!-- return.level(fitGP, c(10,20,100), type="GP") -->
<!-- ``` -->
<!-- ```          -->
<!-- [1] "Return Levels for period units in years" -->
<!--  10-year level  20-year level 100-year level  -->
<!--       2.857184       3.340219       4.581339  -->
<!-- ``` -->
<!-- Threshold exceedances are not always independent due to temporal correlation. If we have high temperatures today, it's likely we might also have high temperatures tomorrow. We have to account for this dependence within our model, for example by using the ARIMA approaches outlined in the time series section. Alternatively, we could use a "declustering" approach which identifies these temporal clusters and simply uses the cluster maxima. -->


</section>

</main> <!-- /main -->
<script>



/* update total correct if #webex-total_correct exists */

update_total_correct = function() {

  console.log("webex: update total_correct");



  var t = document.getElementsByClassName("webex-total_correct");

  for (var i = 0; i < t.length; i++) {

    p = t[i].parentElement;

    var correct = p.getElementsByClassName("webex-correct").length;

    var solvemes = p.getElementsByClassName("webex-solveme").length;

    var radiogroups = p.getElementsByClassName("webex-radiogroup").length;

    var selects = p.getElementsByClassName("webex-select").length;



    t[i].innerHTML = correct + " of " + (solvemes + radiogroups + selects) + " correct";

  }

}



/* webex-solution button toggling function */

b_func = function() {

  console.log("webex: toggle hide");



  var cl = this.parentElement.classList;

  if (cl.contains('open')) {

    cl.remove("open");

  } else {

    cl.add("open");

  }

}



/* check answers */

check_func = function() {

  console.log("webex: check answers");



  var cl = this.parentElement.classList;

  if (cl.contains('unchecked')) {

    cl.remove("unchecked");

    this.innerHTML = "Hide Answers";

  } else {

    cl.add("unchecked");

    this.innerHTML = "Show Answers";

  }

}



/* function for checking solveme answers */

solveme_func = function(e) {

  console.log("webex: check solveme");



  var real_answers = JSON.parse(this.dataset.answer);

  var my_answer = this.value;

  var cl = this.classList;

  if (cl.contains("ignorecase")) {

    my_answer = my_answer.toLowerCase();

  }

  if (cl.contains("nospaces")) {

    my_answer = my_answer.replace(/ /g, "")

  }



  if (my_answer == "") {

    cl.remove("webex-correct");

    cl.remove("webex-incorrect");

  } else if (real_answers.includes(my_answer)) {

    cl.add("webex-correct");

    cl.remove("webex-incorrect");

  } else {

    cl.add("webex-incorrect");

    cl.remove("webex-correct");

  }



  // match numeric answers within a specified tolerance

  if(this.dataset.tol > 0){

    var tol = JSON.parse(this.dataset.tol);

    var matches = real_answers.map(x => Math.abs(x - my_answer) < tol)

    if (matches.reduce((a, b) => a + b, 0) > 0) {

      cl.add("webex-correct");

    } else {

      cl.remove("webex-correct");

    }

  }



  // added regex bit

  if (cl.contains("regex")){

    answer_regex = RegExp(real_answers.join("|"))

    if (answer_regex.test(my_answer)) {

      cl.add("webex-correct");

    }

  }



  update_total_correct();

}



/* function for checking select answers */

select_func = function(e) {

  console.log("webex: check select");



  var cl = this.classList



  /* add style */

  cl.remove("webex-incorrect");

  cl.remove("webex-correct");

  if (this.value == "answer") {

    cl.add("webex-correct");

  } else if (this.value != "blank") {

    cl.add("webex-incorrect");

  }



  update_total_correct();

}



/* function for checking radiogroups answers */

radiogroups_func = function(e) {

  console.log("webex: check radiogroups");



  var checked_button = document.querySelector('input[name=' + this.id + ']:checked');

  var cl = checked_button.parentElement.classList;

  var labels = checked_button.parentElement.parentElement.children;



  /* get rid of styles */

  for (i = 0; i < labels.length; i++) {

    labels[i].classList.remove("webex-incorrect");

    labels[i].classList.remove("webex-correct");

  }



  /* add style */

  if (checked_button.value == "answer") {

    cl.add("webex-correct");

  } else {

    cl.add("webex-incorrect");

  }



  update_total_correct();

}



window.onload = function() {

  console.log("webex onload");

  /* set up solution buttons */

  var buttons = document.getElementsByTagName("button");



  for (var i = 0; i < buttons.length; i++) {

    if (buttons[i].parentElement.classList.contains('webex-solution')) {

      buttons[i].onclick = b_func;

    }

  }



  var check_sections = document.getElementsByClassName("webex-check");

  console.log("check:", check_sections.length);

  for (var i = 0; i < check_sections.length; i++) {

    check_sections[i].classList.add("unchecked");



    let btn = document.createElement("button");

    btn.innerHTML = "Show Answers";

    btn.classList.add("webex-check-button");

    btn.onclick = check_func;

    check_sections[i].appendChild(btn);



    let spn = document.createElement("span");

    spn.classList.add("webex-total_correct");

    check_sections[i].appendChild(spn);

  }



  /* set up webex-solveme inputs */

  var solveme = document.getElementsByClassName("webex-solveme");



  for (var i = 0; i < solveme.length; i++) {

    /* make sure input boxes don't auto-anything */

    solveme[i].setAttribute("autocomplete","off");

    solveme[i].setAttribute("autocorrect", "off");

    solveme[i].setAttribute("autocapitalize", "off");

    solveme[i].setAttribute("spellcheck", "false");

    solveme[i].value = "";



    /* adjust answer for ignorecase or nospaces */

    var cl = solveme[i].classList;

    var real_answer = solveme[i].dataset.answer;

    if (cl.contains("ignorecase")) {

      real_answer = real_answer.toLowerCase();

    }

    if (cl.contains("nospaces")) {

      real_answer = real_answer.replace(/ /g, "");

    }

    solveme[i].dataset.answer = real_answer;



    /* attach checking function */

    solveme[i].onkeyup = solveme_func;

    solveme[i].onchange = solveme_func;



    solveme[i].insertAdjacentHTML("afterend", " <span class='webex-icon'></span>")

  }



  /* set up radiogroups */

  var radiogroups = document.getElementsByClassName("webex-radiogroup");

  for (var i = 0; i < radiogroups.length; i++) {

    radiogroups[i].onchange = radiogroups_func;

  }



  /* set up selects */

  var selects = document.getElementsByClassName("webex-select");

  for (var i = 0; i < selects.length; i++) {

    selects[i].onchange = select_func;

    selects[i].insertAdjacentHTML("afterend", " <span class='webex-icon'></span>")

  }



  update_total_correct();

}



</script>

<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p><a href="https://envstats-stats4009-stats503.github.io/Course_Notes/2025_26/Module_2/docs/" style="color:#ccc;">Home</a></p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>